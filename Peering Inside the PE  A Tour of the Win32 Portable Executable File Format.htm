<!DOCTYPE html>


<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head><link rel="canonical" href="https://msdn.microsoft.com/en-us/library/ms809762.aspx" />
    <title>Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</title>







<meta name="DCS.dcsuri" content="/en-us/library/ms809762(d=default,l=en-us,v=msdn.10).aspx" />

<meta name="NormalizedUrl" content="https://msdn.microsoft.com/en-us/library/ms809762(d=default,l=en-us,v=msdn.10).aspx" />

<meta name="ms.normalizedurl" content="https://msdn.microsoft.com/en-us/library/ms809762(d=default,l=en-us,v=msdn.10).aspx" />

<meta name="VotingContextUrl" content="https://msdn.microsoft.com/en-us/library/ms809762(d=default,l=en-us,v=msdn.10).aspx" />

<meta name="MN" content="9DDD8834-11:08:16 AM" />

<meta name="Search.ShortId" content="ms809762" />

<meta name="ms.shortidmsdn" content="ms809762" />

<meta name="Ms.Locale" content="en-us" />

<meta name="ms.prodver" content="MSDN.10" />

<meta name="ms.contentlang" content="EN" />

<meta name="ms.lang" content="EN" />

<meta name="ms.loc" content="US" />

<meta name="ms.sitever" content="2015.11.05.5" />

<meta name="ms.assetid" content="MSDN|dndebug|~\html\msdn_peeringpe.htm" />

<meta name="ms.auth" content="0" />

<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    
    









    <script type="text/javascript" data-do-not-move="true">
        //<![CDATA[
        var AmbientContext = null;

        (function(){
            var root = (function(){return this;}).call(null);

            var GetCookie = function(name){
                var cookies = root.document.cookie ? root.document.cookie.split('; ') : [];
                for (var i = 0; i < cookies.length; i++) {
                    var pos = cookies[i].indexOf('=');
                    if (name === root.decodeURIComponent(cookies[i].slice(0, pos)))
                    {
                        var cookie = cookies[i].slice(pos + 1).replace(/\+/g, ' ');
                        cookie = root.decodeURIComponent(cookie);
                        return cookie;
                    }
                }
            };

            var JsonDeserialize = function(content) {
                return root.JSON && root.JSON.parse ? root.JSON.parse(content) : (new Function('return (' + content + ')'))();
            };

            try {
                AmbientContext = GetCookie('AmbientContext');
                AmbientContext = AmbientContext && JsonDeserialize(AmbientContext);
            } catch(ex) {
            } finally {
                AmbientContext = AmbientContext || null;
            }
        })();
        //]]>
    </script>

    <script type="text/javascript" src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.2.min.js" data-do-not-move="true" data-provides="jQuery"></script>
    
<link rel="stylesheet" type="text/css" href="https://i-msdn.sec.s-msft.com/Combined.css?resources=0:ImageSprite,0:TopicResponsive,0:TopicResponsive.MediaQueries,1:CodeSnippet,1:ProgrammingSelector,1:ExpandableCollapsibleArea,0:CommunityContent,1:TopicNotInScope,1:FeedViewerBasic,1:ImageSprite,2:Header,2:HeaderFooterSprite,2:Header.MediaQueries,3:Banner.MediaQueries,0:Breadcrumbs,0:Breadcrumbs.MediaQueries,0:ResponsiveToc,0:ResponsiveToc.MediaQueries,0:LibraryMemberFilter,4:SkinnyRating,2:Footer,2:Footer.MediaQueries,5:NewFooterSock,5:NewFooterSock.MediaQueries,5:LinkList,0:BaseResponsive,6:MsdnResponsive,0:Tables.MediaQueries;/Areas/Library/Content:0,/Areas/Epx/Content/Css:1,/Areas/Centers/Themes/StandardDevCenter/Content:2,/Areas/Epx/Shared/Content:3,/Areas/Library/Themes/Base/Content:4,/Areas/Epx/Themes/Base/Content:5,/Areas/Library/Themes/Msdn/Content:6&amp;amp;v=395D1E6FB76766645AACB63D09F3F782" /></head>
<body class="library FF FF3">
    <div id="page">

        

        
    

    
    <link type="text/css" rel="stylesheet" />
    
        
        
    <input type="hidden" id="isHeaderBleeding" value="true" />
    <div id="ux-header" dir="ltr" class="ltr msdn">
        

      <header>
        <span id="singleCol"></span>
        <span id="doubleCol"></span>
        <span id="isMobile"></span>
        <div>
          <div class="row topRow">
            <div class="top">
              <div class="left">
                  <a class="msdnLogoImg" href="https://msdn.microsoft.com/en-us" title="MSDN home">
                      <div id="msft-logo" class="msft-logo"></div>
                  </a>
                <div class="GrayPipe"></div>
                  <a class="DevCenterFullNameNonMegaBlade" href="https://msdn.microsoft.com/en-us">Developer Network</a>
                <a class="DevCenterFullName" href="https://msdn.microsoft.com/en-us">Developer Network</a>
                <a class="DevCenterShortName" href="https://msdn.microsoft.com/en-us">Developer</a>
              </div>
              <div class="right">
                <div id="signIn">

  <img class="profileImage" src="https://i-msdn.sec.s-msft.com/Areas/Centers/Themes/StandardDevCenter/Content/Images/profile.jpg?v=635823572930622724" />



<a class="scarabLink" href="https://login.live.com/login.srf?wa=wsignin1.0&amp;rpsnv=12&amp;ct=1447787296&amp;rver=6.0.5276.0&amp;wp=MCMBI&amp;wlcxt=MSDN%24MSDN%24MSDN&amp;wreply=https%3a%2f%2fmsdn.microsoft.com%2fen-us%2flibrary%2fms809762.aspx&amp;lc=1033&amp;id=254354&amp;mkt=en-US" title="Sign in">Sign in</a></div>




                <div class="auxNav">
                  <div>
                    <div data-fragmentName="Subscriptions" id="Fragment_Subscriptions" xmlns="http://www.w3.org/1999/xhtml">
  <a href="https://msdn.microsoft.com/subscriptions/manage/hh442900" id="Subscriptions_2153_1" xmlns="http://www.w3.org/1999/xhtml">MSDN subscriptions</a>
</div>
                    <div data-fragmentName="GetTools" id="Fragment_GetTools" xmlns="http://www.w3.org/1999/xhtml">
  <a href="http://go.microsoft.com/fwlink/?LinkId=309297&amp;clcid=0x409&amp;slcid=0x409&amp;campaign=o~msft~msdn~gettools-header~dn308572" id="GetTools_2153_3" xmlns="http://www.w3.org/1999/xhtml">Get tools</a>
</div>
                  </div>                    
                </div>
              </div>
            </div>

          </div>
          <div class="row middleRow">
            <div class="expandTop">
              <div class="left"></div>
              <div class="right"></div>
            </div>
          </div>
        </div>
        <div id="buttomRowWrapper" class="bg_default">
          <div class="row buttomRow bg_default">
            <div class="bottom">
              <div class="left">
                <a id="grip" class="menu-icon" href="javascript:void(0)"></a>
                
                <div id="drawer">
                  <div class="toc">
                    
        <nav>
            <ul class="navL1">
                        <li class="inactive toggle">
                            <a href="javascript:void(0)" title="Technologies">Technologies</a>
                                <ul class="navL2">
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/cloud-app-development-msdn" title="Cloud">Cloud</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/app-development-msdn" title="App Development">App Development</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/web-app-development-msdn" title="Web">Web</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/big-data-development-msdn" title="Data">Data</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/games-development-msdn" title="Gaming">Gaming</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/internetofthings" title="Internet of Things">Internet of Things</a>

                                                   
                                        </li>
                                </ul>
                        </li>
                        <li class="inactive toggle">
                            <a href="javascript:void(0)" title="Downloads">Downloads</a>
                                <ul class="navL2">
                                        <li class="inactive">
                                            <a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="Visual Studio">Visual Studio</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/subscriptions" title="MSDN subscription access">MSDN subscription access</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/microsoft-sdks-msdn" title="SDKs">SDKs</a>

                                                   
                                        </li>
                                        <li class="inactive toggle">
                                            <a href="javascript:void(0)" title="Trial software">Trial software</a>

                                                <ul class="navL3">
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/evalcenter" title="Free downloads">Free downloads</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/officeevaluationresources" title="Office resources">Office resources</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/sharepoint2013resources" title="SharePoint Server 2013 resources">SharePoint Server 2013 resources</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/sqlserver2014expressresources" title="SQL Server 2014 Express resources">SQL Server 2014 Express resources</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/windowsserver2012r2resources" title="Windows Server 2012 resources">Windows Server 2012 resources</a>
                                                        </li>
                                                </ul>
                                                   
                                        </li>
                                </ul>
                        </li>
                        <li class="inactive toggle">
                            <a href="javascript:void(0)" title="Programs">Programs</a>
                                <ul class="navL2">
                                        <li class="inactive toggle">
                                            <a href="javascript:void(0)" title="MSDN Subscriptions">MSDN Subscriptions</a>

                                                <ul class="navL3">
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/msdn-subscriptions-overview" title="Overview">Overview</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/benefits-overview" title="Benefits">Benefits</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/msdn-subscriptions-administration" title="Administrators">Administrators</a>
                                                        </li>
                                                </ul>
                                                   
                                        </li>
                                        <li class="inactive toggle">
                                            <a href="javascript:void(0)" title="Students">Students</a>

                                                <ul class="navL3">
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/imagine/imagine-home" title="Microsoft Imagine">Microsoft Imagine</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/microsoftstudentpartners" title="Microsoft Student Partners">Microsoft Student Partners</a>
                                                        </li>
                                                </ul>
                                                   
                                        </li>
                                        <li class="inactive toggle">
                                            <a href="javascript:void(0)" title="Architects">Architects</a>

                                                <ul class="navL3">
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/architects-overview-msdn" title="Overview">Overview</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/architects-case-studies-msdn" title="Case studies">Case studies</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="https://msdn.microsoft.com/architects-blueprints-msdn" title="Blueprints">Blueprints</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="http://blogs.msdn.com/b/msarchitecture/" title="Blog">Blog</a>
                                                        </li>
                                                        <li class="inactive">
                                                            <a href="http://social.msdn.microsoft.com/forums/en-us/home?brandignore=true&amp;sort=relevancedesc&amp;searchterm=architecture+or+architect" title="Forums">Forums</a>
                                                        </li>
                                                </ul>
                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/applicationbuilder" title="ISV">ISV</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://www.microsoft.com/bizspark" title="Startups">Startups</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://rewards.msdn.microsoft.com/" title="TechRewards">TechRewards</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="http://events.msdn.microsoft.com/" title="Events">Events</a>

                                                   
                                        </li>
                                </ul>
                        </li>
                        <li class="inactive toggle">
                            <a href="javascript:void(0)" title="Community">Community</a>
                                <ul class="navL2">
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/magazine/dd767791" title="Magazine">Magazine</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://social.msdn.microsoft.com/forums/" title="Forums">Forums</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="http://blogs.msdn.com/b/developer-tools/" title="Blogs">Blogs</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="http://tech-advisors.msdn.microsoft.com/en-us" title="Tech Advisors">Tech Advisors</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="http://channel9.msdn.com/" title="Channel 9">Channel 9</a>

                                                   
                                        </li>
                                </ul>
                        </li>
                        <li class="inactive current toggle">
                            <a href="javascript:void(0)" title="Documentation">Documentation</a>
                                <ul class="navL2">
                                        <li class="inactive current">
                                            <a href="https://msdn.microsoft.com/library" title="APIs and reference">APIs and reference</a>

                                                   
                                        </li>
                                        <li class="inactive">
                                            <a href="https://msdn.microsoft.com/developer-centers-msdn" title="Dev centers">Dev centers</a>

                                                   
                                        </li>
                                </ul>
                        </li>
                        <li class="inactive">
                            <a href="https://code.msdn.microsoft.com/" title="Samples">Samples</a>
                        </li>
            </ul>
        </nav>

                  </div>
                </div>
              </div>
              <div class="right">
                <div data-fragmentName="SearchBox" id="Fragment_SearchBox" xmlns="http://www.w3.org/1999/xhtml">
  <div class="SearchBox">
    <form id="HeaderSearchForm" name="HeaderSearchForm" method="get">
      <button id="FakeHeaderSearchButton" value="Search" type="submit" class="header-search-button">
        <div id="search-finder" class="search-finder"></div>
      </button>
      <button id="HeaderSearchButton" style="display:none"></button>
      <div id="searchSplitter"></div>
      <div id="searchCloseIcon" class="search-clear-x"></div>
      <div id="searchTextContainer" style="width: 0;">
        <input id="HeaderSearchTextBox" name="query" type="text" maxlength="200" onfocus="Epx.Controls.SearchBox.watermarkFocus(event, this.title)" onblur="Epx.Controls.SearchBox.watermarkBlur(event, this.title)" />
      </div>
    </form>
    
    
  </div>
</div>
              </div>
            </div>
          </div>
        </div>

      </header>

    </div>

    
    





<link type="text/css" rel="stylesheet" />
<link type="text/css" rel="stylesheet" />


    <div id="breadcrumbs">
        <div id="breadcrumbDesktop" class="breadCrumb">
                        <span class="breadcrumbEllipsis"><a href="https://msdn.microsoft.com/en-us/library/ee663300(v=vs.85).aspx" title="Windows Desktop App Development"></a></span>
                        <span><a href="https://msdn.microsoft.com/en-us/library/hh529126(v=vs.85).aspx" title="Archive"><span>Archive</span></a></span>
                        <span><a href="https://msdn.microsoft.com/en-us/library/hh703252(v=vs.85).aspx" title="Diagnostics"><span>Diagnostics</span></a></span>
                        <span class="breadcrumbDropSmall">
                            <a id="breadcrumbDropDownButton" href="#" targethref="https://msdn.microsoft.com/en-us/library/hh703252(v=vs.85).aspx" title="Debugging and Error Handling"><span>Debugging and Error Handling</span></a>
                        </span>
        </div>
        <div id="breadcrumbDropDownMenu"></div>
        <div id="tocDropDownMenu"></div>

        <div id="breadcrumbTablet" class="breadCrumb">
                        <span class="breadcrumbEllipsis"><a href="https://msdn.microsoft.com/en-us/library/hh703252(v=vs.85).aspx" title="Diagnostics"></a></span>
                    <span><a href="https://msdn.microsoft.com/en-us/library/hh700248(v=vs.85).aspx" title="Debugging and Error Handling"><span>Debugging and Error Handling</span></a></span>
                <span class="breadcrumbDropSmall"><a id="tocDropDownButton" href="#" title="Peering Inside the PE: A Tour of the Win32 Portable Executable File Format"><span>Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</span></a></span>
        </div>
        <div id="breadcrumbMobile" class="breadCrumb">
                <span class="breadcrumbEllipsis"><a href="https://msdn.microsoft.com/en-us/library/hh700248(v=vs.85).aspx" title="Debugging and Error Handling"></a></span>
            <span class="breadcrumbDropSmall"><a id="tocPopupButton" href="#" title="Peering Inside the PE: A Tour of the Win32 Portable Executable File Format"><span>Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</span></a></span>
        </div>
    </div>
    <div id="tocPopupMenu">
        <div id="tocPopMenuClose" class="tocCloseLarge"></div>
        <div id="tocTitle">Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</div>        
    </div>

    


        <div id="body">
            <span id="tabletView_large"></span>
            <span id="tabletView_small"></span>
            <span id="mobileView"></span>
            









    <div id="leftNav">





<div id="tocnav" class="hide-archive" ms.pgarea="left toc">


    <div class="tocunselected">
        <div id="tocExpandArea">
            <span class="toc_empty"></span>
            <span id="tocExpandButton"><a href="#"></a></span>
        </div>
        <div id="tocExpand"></div>
    </div>
    <div class="tocselected"></div>
    <div class="tocunselected">
                <div class="toclevel current" data-toclevel="1">
<a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx" mtpsaliasid="" mtpsassetid="" mtpsshortid="" title="Peering Inside the PE: A Tour of the Win32 Portable Executable File Format">Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</a>                </div>
                <div class="toclevel " data-toclevel="1">
<a href="https://msdn.microsoft.com/en-us/library/ms809754.aspx" mtpsaliasid="" mtpsassetid="" mtpsshortid="" title="The Debugging Application Programming Interface">The Debugging Application Programming Interface</a>                </div>
    </div>
    <a id="tocMenuToggler" href="#">
        <span id="tocMenuTogglerIcon" class="tocMenuCollapse"></span>
        <div id="tocMenuTogglerLabel">TOC</div>
    </a>
</div>            <div style="display:none">
                <div id="CollapseLocalizeString">Collapse the table of content</div>
                <div id="ExpandLocalizeString">Expand the table of content</div>
            </div>
        <div>
            <a id="isd_archiveControlResponsive" style="display:none;" data-include-archive="Include Previous Version" data-exclude-archive="Exclude Previous Version">
            </a>
        </div>
    </div>
    <div id="content" class="content">








<div class="topic" xmlns="http://www.w3.org/1999/xhtml">
  <h1 class="title">Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</h1>
  
  <a id="msdn_peeringpe">
    
  </a>


<div id="nstext"> 
<p>Matt Pietrek</p>

<p>March 1994</p>

<p><em>Matt Pietrek is the author of</em> Windows Internals<em> (Addison-Wesley, 1993). He works at Nu-Mega Technologies Inc., and can be reached via CompuServe: 71774,362</em></p>

<p><em>This article is reproduced from the March 1994 issue of </em>Microsoft Systems Journal<em>. Copyright © 1994 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</em></p>

<p><em>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</em></p>
<br />
<p>The format of an operating system's executable file is in many ways a mirror of the operating system. Although studying an executable file format isn't usually high on most programmers' list of things to do, a great deal of knowledge can be gleaned this way. In this article, I'll give a tour of the Portable Executable (PE) file format that Microsoft has designed for use by all their Win32®-based systems: Windows NT®, Win32s™, and Windows® 95. The PE format plays a key role in all of Microsoft's operating systems for the foreseeable future, including Windows 2000. If you use Win32s or Windows NT, you're already using PE files. Even if you program only for Windows 3.1 using Visual C++®, you're still using PE files (the 32-bit MS-DOS® extended components of Visual C++ use this format). In short, PEs are already pervasive and will become unavoidable in the near future. Now is the time to find out what this new type of executable file brings to the operating system party.</p>

<p>I'm not going to make you stare at endless hex dumps and chew over the significance of individual bits for pages on end. Instead, I'll present the concepts embedded in the PE file format and relate them to things you encounter everyday. For example, the notion of thread local variables, as in </p>


<div id="code-snippet-1" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_43f32081-f71b-42eb-959d-4bfb57b53c8a');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_43f32081-f71b-42eb-959d-4bfb57b53c8a" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
declspec(thread) int i;

</pre></div>
            
        </div>
    </div>
</div>


<p>drove me crazy until I saw how it was implemented with elegant simplicity in the executable file. Since many of you are coming from a background in 16-bit Windows, I'll correlate the constructs of the Win32 PE file format back to their 16-bit NE file format equivalents. </p>

<p>In addition to a different executable format, Microsoft also introduced a new object module format produced by their compilers and assemblers. This new OBJ file format has many things in common with the PE executable format. I've searched in vain to find any documentation on the new OBJ file format. So I deciphered it on my own, and will describe parts of it here in addition to the PE format.</p>

<p>It's common knowledge that Windows NT has a VAX® VMS® and UNIX® heritage. Many of the Windows NT creators designed and coded for those platforms before coming to Microsoft. When it came time to design Windows NT, it was only natural that they tried to minimize their bootstrap time by using previously written and tested tools. The executable and object module format that these tools produced and worked with is called COFF (an acronym for Common Object File Format). The relative age of COFF can be seen by things such as fields specified in octal format. The COFF format by itself was a good starting point, but needed to be extended to meet all the needs of a modern operating system like Windows NT or Windows 95. The result of this updating is the Portable Executable format. It's called "portable" because all the implementations of Windows NT on various platforms (x86, MIPS®, Alpha, and so on) use the same executable format. Sure, there are differences in things like the binary encodings of CPU instructions. The important thing is that the operating system loader and programming tools don't have to be completely rewritten for each new CPU that arrives on the scene.</p>

<p>The strength of Microsoft's commitment to get Windows NT up and running quickly is evidenced by the fact that they abandoned existing 32-bit tools and file formats. Virtual device drivers written for 16-bit Windows were using a different 32-bit file layout—the LE format—long before Windows NT appeared on the scene. More important than that is the shift of OBJ formats. Prior to the Windows NT C compiler, all Microsoft compilers used the Intel OMF (Object Module Format) specification. As mentioned earlier, the Microsoft compilers for Win32 produce COFF-format OBJ files. Some Microsoft competitors such as Borland and Symantec have chosen to forgo the COFF format OBJs and stick with the Intel OMF format. The upshot of this is that companies producing OBJs or LIBs for use with multiple compilers will need to go back to distributing separate versions of their products for different compilers (if they weren't already).</p>

<p>The PE format is documented (in the loosest sense of the word) in the WINNT.H header file. About midway through WINNT.H is a section titled "Image Format." This section starts out with small tidbits from the old familiar MS-DOS MZ format and NE format headers before moving into the newer PE information. WINNT.H provides definitions of the raw data structures used by PE files, but contains only a few useful comments to make sense of what the structures and flags mean. Whoever wrote the header file for the PE format (the name Michael J. O'Leary keeps popping up) is certainly a believer in long, descriptive names, along with deeply nested structures and macros. When coding with WINNT.H, it's not uncommon to have expressions like this:</p>


<div id="code-snippet-2" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_5890c0a0-3612-4c7c-9bd1-df3a8aa6c64f');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_5890c0a0-3612-4c7c-9bd1-df3a8aa6c64f" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
pNTHeader-&gt;
OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

</pre></div>
            
        </div>
    </div>
</div>


<p>To help make logical sense of the information in WINNT.H, read the Portable Executable and Common Object File Format Specification, available on MSDN Library quarterly CD-ROM releases up to and including October 2001.</p>

<p>Turning momentarily to the subject of COFF-format OBJs, the WINNT.H header file includes structure definitions and typedefs for COFF OBJ and LIB files. Unfortunately, I've been unable to find any documentation on this similar to that for the executable file mentioned above. Since PE files and COFF OBJ files are so similar, I decided that it was time to bring these files out into the light and document them as well.</p>

<p>Beyond just reading about what PE files are composed of, you'll also want to dump some PE files to see these concepts for yourself. If you use Microsoft® tools for Win32-based development, the DUMPBIN program will dissect and output PE files and COFF OBJ/LIB files in readable form. Of all the PE file dumpers, DUMPBIN is easily the most comprehensive. It even has a nifty option to disassemble the code sections in the file it's taking apart. Borland users can use TDUMP to view PE executable files, but TDUMP doesn't understand the COFF OBJ files. This isn't a big deal since the Borland compiler doesn't produce COFF-format OBJs in the first place. </p>

<p>I've written a PE and COFF OBJ file dumping program, PEDUMP (see Table 1), that I think provides more understandable output than DUMPBIN. Although it doesn't have a disassembler or work with LIB files, it is otherwise functionally equivalent to DUMPBIN, and adds a few new features to make it worth considering. The source code for PEDUMP is available on any MSJ bulletin board, so I won't list it here in its entirety. Instead, I'll show sample output from PEDUMP to illustrate the concepts as I describe them. </p>

<p class="label"><strong>Table 1. PEDUMP.C</strong></p>


<div id="code-snippet-3" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_581d79ca-9448-4ffe-a51b-57338a75d5ce');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_581d79ca-9448-4ffe-a51b-57338a75d5ce" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
//--------------------
// PROGRAM: PEDUMP
// FILE:    PEDUMP.C
// AUTHOR:  Matt Pietrek - 1993
//--------------------
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include "objdump.h"
#include "exedump.h"
#include "extrnvar.h"

// Global variables set here, and used in EXEDUMP.C and OBJDUMP.C
BOOL fShowRelocations = FALSE;
BOOL fShowRawSectionData = FALSE;
BOOL fShowSymbolTable = FALSE;
BOOL fShowLineNumbers = FALSE;

char HelpText[] = 
"PEDUMP - Win32/COFF .EXE/.OBJ file dumper - 1993 Matt Pietrek\n\n"
"Syntax: PEDUMP [switches] filename\n\n"
"  /A    include everything in dump\n"
"  /H    include hex dump of sections\n"
"  /L    include line number information\n"
"  /R    show base relocations\n"
"  /S    show symbol table\n";

// Open up a file, memory map it, and call the appropriate dumping routine
void DumpFile(LPSTR filename)
{
    HANDLE hFile;
    HANDLE hFileMapping;
    LPVOID lpFileBase;
    PIMAGE_DOS_HEADER dosHeader;
    
    hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                    
    if ( hFile = = INVALID_HANDLE_VALUE )
    {   printf("Couldn't open file with CreateFile()\n");
        return; }
    
    hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if ( hFileMapping = = 0 )
    {   CloseHandle(hFile);
        printf("Couldn't open file mapping with CreateFileMapping()\n");
        return; }
    
    lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if ( lpFileBase = = 0 )
    {
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        printf("Couldn't map view of file with MapViewOfFile()\n");
        return;
    }

    printf("Dump of file %s\n\n", filename);
    
    dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
    if ( dosHeader-&gt;e_magic = = IMAGE_DOS_SIGNATURE )
       { DumpExeFile( dosHeader ); }
    else if ( (dosHeader-&gt;e_magic = = 0x014C)    // Does it look like a i386
              &amp;&amp; (dosHeader-&gt;e_sp = = 0) )        // COFF OBJ file???
    {
        // The two tests above aren't what they look like.  They're
        // really checking for IMAGE_FILE_HEADER.Machine = = i386 (0x14C)
        // and IMAGE_FILE_HEADER.SizeOfOptionalHeader = = 0;
        DumpObjFile( (PIMAGE_FILE_HEADER)lpFileBase );
    }
    else
        printf("unrecognized file format\n");
    UnmapViewOfFile(lpFileBase);
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
}

// process all the command line arguments and return a pointer to
// the filename argument.
PSTR ProcessCommandLine(int argc, char *argv[])
{
    int i;
    
    for ( i=1; i &lt; argc; i++ )
    {
        strupr(argv[i]);
        
        // Is it a switch character?
        if ( (argv[i][0] = = '-') || (argv[i][0] = = '/') )
        {
            if ( argv[i][1] = = 'A' )
            {   fShowRelocations = TRUE;
                fShowRawSectionData = TRUE;
                fShowSymbolTable = TRUE;
                fShowLineNumbers = TRUE; }
            else if ( argv[i][1] = = 'H' )
                fShowRawSectionData = TRUE;
            else if ( argv[i][1] = = 'L' )
                fShowLineNumbers = TRUE;
            else if ( argv[i][1] = = 'R' )
                fShowRelocations = TRUE;
            else if ( argv[i][1] = = 'S' )
                fShowSymbolTable = TRUE;
        }
        else    // Not a switch character.  Must be the filename
        {   return argv[i]; }
    }
}

int main(int argc, char *argv[])
{
    PSTR filename;
    
    if ( argc = = 1 )
    {   printf(    HelpText );
        return 1; }
    
    filename = ProcessCommandLine(argc, argv);
    if ( filename )
        DumpFile( filename );
    return 0;
}
  
</pre></div>
            
        </div>
    </div>
</div>


<h2 class="dtH1">Win32 and PE Basic Concepts</h2>

<p>Let's go over a few fundamental ideas that permeate  the design of a PE file (see Figure 1). I'll use the term "module" to mean the code, data, and resources of an executable file or DLL that have been loaded into memory. Besides code and data that your program uses directly, a module is also composed of the supporting data structures used by Windows to determine where the code and data is located in memory. In 16-bit Windows, the supporting data structures are in the module database (the segment referred to by an HMODULE). In Win32, these data structures are in the PE header, which I'll explain shortly.</p>

<p class="fig"><code><img id="peeringpe1" alt="ms809762.peeringpe1(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC155437.gif" title="ms809762.peeringpe1(en-us,MSDN.10).gif" xmlns="" /></code></p>

<p class="label"><strong>Figure 1. The PE file format</strong></p>

<p>The first important thing to know about PE files is that the executable file on disk is very similar to what the module will look like after Windows has loaded it. The Windows loader doesn't need to work extremely hard to create a process from the disk file. The loader uses the memory-mapped file mechanism to map the appropriate pieces of the file into the virtual address space. To use a construction analogy, a PE file is like a prefabricated home. It's essentially brought into place in one piece, followed by a small amount of work to wire it up to the rest of the world (that is, to connect it to its DLLs and so on). This same ease of loading applies to PE-format DLLs as well. Once the module has been loaded, Windows can effectively treat it like any other memory-mapped file.</p>

<p>This is in marked contrast to the situation in 16-bit Windows. The 16-bit NE file loader reads in portions of the file and creates completely different data structures to represent the module in memory. When a code or data segment needs to be loaded, the loader has to allocate a new segment from the global heap, find where the raw data is stored in the executable file, seek to that location, read in the raw data, and apply any applicable fixups. In addition, each 16-bit module is responsible for remembering all the selectors it's currently using, whether the segment has been discarded, and so on.</p>

<p>For Win32, all the memory used by the module for code, data, resources, import tables, export tables, and other required module data structures is in one contiguous block of memory. All you need to know in this situation is where the loader mapped the file into memory. You can easily find all the various pieces of the module by following pointers that are stored as part of the image.</p>

<p>Another idea you should be acquainted with is the Relative Virtual Address (RVA). Many fields in PE files are specified in terms of RVAs. An RVA is simply the offset of some item, relative to where the file is memory-mapped. For example, let's say the loader maps a PE file into memory starting at address 0x10000 in the virtual address space. If a certain table in the image starts at address 0x10464, then the table's RVA is 0x464.</p>


<div id="code-snippet-4" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_02376cf1-747e-4fd3-b955-c2e14fc68f67');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_02376cf1-747e-4fd3-b955-c2e14fc68f67" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
 (Virtual address 0x10464)-(base address 0x10000) = RVA 0x00464

</pre></div>
            
        </div>
    </div>
</div>


<p>To convert an RVA into a usable pointer, simply add the RVA to the base address of the module. The base address is the starting address of a memory-mapped EXE or DLL and is an important concept in Win32. For the sake of convenience, Windows NT and Windows 95 uses the base address of a module as the module's instance handle (HINSTANCE). In Win32, calling the base address of a module an HINSTANCE is somewhat confusing, because the term "instance handle" comes from 16-bit Windows. Each copy of an application in 16-bit Windows gets its own separate data segment (and an associated global handle) that distinguishes it from other copies of the application, hence the term instance handle. In Win32, applications don't need to be distinguished from one another because they don't share the same address space. Still, the term HINSTANCE persists to keep continuity between 16-bit Windows and Win32. What's important for Win32 is that you can call GetModuleHandle for any DLL that your process uses to get a pointer for accessing the module's components.</p>

<p>The final concept that you need to know about PE files is sections. A section in a PE file is roughly equivalent to a segment or the resources in an NE file. Sections contain either code or data. Unlike segments, sections are blocks of contiguous memory with no size constraints. Some sections contain code or data that your program declared and uses directly, while other data sections are created for you by the linker and librarian, and contain information vital to the operating system. In some descriptions of the PE format, sections are also referred to as objects. The term object has so many overloaded meanings that I'll stick to calling the code and data areas sections. </p>

<h2 class="dtH1">The PE Header</h2>

<p>Like all other executable file formats, the PE file has a collection of fields at a known (or easy to find) location that define what the rest of the file looks like. This header contains information such as the locations and sizes of the code and data areas, what operating system the file is intended for, the initial stack size, and other vital pieces of information that I'll discuss shortly. As with other executable formats from Microsoft, this main header isn't at the very beginning of the file. The first few hundred bytes of the typical PE file are taken up by the MS-DOS stub. This stub is a tiny program that prints out something to the effect of "This program cannot be run in MS-DOS mode." So if you run a Win32-based program in an environment that doesn't support Win32, you'll get this informative error message. When the Win32 loader memory maps a PE file, the first byte of the mapped file corresponds to the first byte of the MS-DOS stub. That's right. With every Win32-based program you start up, you get an MS-DOS-based program loaded for free!</p>

<p>As in other Microsoft executable formats, you find the real header by looking up its starting offset, which is stored in the MS-DOS stub header. The WINNT.H file includes a structure definition for the MS-DOS stub header that makes it very easy to look up where the PE header starts. The e_lfanew field is a relative offset (or RVA, if you prefer) to the actual PE header. To get a pointer to the PE header in memory, just add that field's value to the image base:</p>


<div id="code-snippet-5" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_8ee59058-d038-4ef7-bc69-b0621e208d37');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_8ee59058-d038-4ef7-bc69-b0621e208d37" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
// Ignoring typecasts and pointer conversion issues for clarity...
pNTHeader = dosHeader + dosHeader-&gt;e_lfanew;

</pre></div>
            
        </div>
    </div>
</div>


<p>Once you have a pointer to the main PE header, the fun can begin. The main PE header is a structure of type IMAGE_NT_HEADERS, which is defined in WINNT.H. This structure is composed of a DWORD and two substructures and is laid out as follows:</p>


<div id="code-snippet-6" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_5a75175e-662a-4ccf-aeb2-b024cf9c6d28');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_5a75175e-662a-4ccf-aeb2-b024cf9c6d28" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
DWORD Signature;
IMAGE_FILE_HEADER FileHeader;
IMAGE_OPTIONAL_HEADER OptionalHeader;

</pre></div>
            
        </div>
    </div>
</div>


<p>The Signature field viewed as ASCII text is "PE\0\0". If after using the e_lfanew field in the MS-DOS header, you find an NE signature here rather than a PE, you're working with a 16-bit Windows NE file. Likewise, an LE in the signature field would indicate a Windows 3.x virtual device driver (VxD). An LX here would be the mark of a file for OS/2 2.0. </p>

<p>Following the PE signature DWORD in the PE header is a structure of type IMAGE_FILE_HEADER. The fields of this structure contain only the most basic information about the file. The structure appears to be unmodified from its original COFF implementations. Besides being part of the PE header, it also appears at the very beginning of the COFF OBJs produced by the Microsoft Win32 compilers. The fields of the IMAGE_FILE_HEADER are shown in Table 2.</p>

<p class="label"><strong>Table 2. IMAGE_FILE_HEADER Fields</strong>

</p><dl>
<dt><code class="ce">WORD    Machine</code></dt>

<dd>The CPU that this file is intended for. The following CPU IDs are defined:
<div class="tablediv"><table class="dtTABLE">

<tr><td>0x14d</td><td>Intel i860</td></tr>

<tr><td>    0x14c</td><td>Intel I386 (same ID used for 486 and 586)</td></tr>

<tr><td>    0x162</td><td>MIPS R3000</td></tr>

<tr><td>    0x166</td><td>MIPS R4000</td></tr>

<tr><td>    0x183</td><td>DEC Alpha AXP</td></tr>
</table></div>
</dd>
</dl>

<p>

</p><dl>
<dt><code class="ce">WORD    NumberOfSections</code></dt>

<dd>The number of sections in the file.</dd>

<dt><code class="ce">DWORD   TimeDateStamp</code></dt>

<dd>The time that the linker (or compiler for an OBJ file) produced this file. This field holds the number of seconds since December 31st, 1969, at 4:00 P.M.</dd>

<dt><code class="ce">DWORD   PointerToSymbolTable</code></dt>

<dd>The file offset of the COFF symbol table. This field is only used in OBJ files and PE files with COFF debug information. PE files support multiple debug formats, so debuggers should refer to the IMAGE_DIRECTORY_ENTRY_DEBUG entry in the data directory (defined later). </dd>

<dt><code class="ce">DWORD   NumberOfSymbols</code></dt>

<dd>The number of symbols in the COFF symbol table. See above.</dd>

<dt><code class="ce">WORD    SizeOfOptionalHeader</code></dt>

<dd>The size of an optional header that can follow this structure. In OBJs, the field is 0. In executables, it is the size of the IMAGE_OPTIONAL_HEADER structure that follows this structure.</dd>

<dt><code class="ce">WORD    Characteristics</code></dt>

<dd>Flags with information about the file. Some important fields:
<div class="tablediv"><table class="dtTABLE">

<tr><td>
<blockquote class="dtBlock"><div>
0x0001</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
There are no relocations in this file</div></blockquote>
</td></tr>

<tr><td>
<blockquote class="dtBlock"><div>
0x0002</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
File is an executable image (not a OBJ or LIB)</div></blockquote>
</td></tr>

<tr><td>
<blockquote class="dtBlock"><div>
0x2000</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
File is a dynamic-link library, not a program</div></blockquote>
</td></tr>
</table></div>

</dd>
</dl>

<blockquote class="dtBlock"><div>
Other fields are defined in WINNT.H</div></blockquote>

<p>The third component of the PE header is a structure of type IMAGE_OPTIONAL_HEADER. For PE files, this portion certainly isn't optional. The COFF format allows individual implementations to define a structure of additional information beyond the standard IMAGE_FILE_HEADER. The fields in the IMAGE_OPTIONAL_HEADER are what the PE designers felt was critical information beyond the basic information in the IMAGE_FILE_HEADER.</p>

<p>All of the fields of the IMAGE_OPTIONAL_HEADER aren't necessarily important to know about (see Figure 4). The more important ones to be aware of are the ImageBase and the Subsystem fields. You can skim or skip the description of the fields.</p>

<p class="label"><strong>Table 3. IMAGE_OPTIONAL_HEADER Fields</strong>

</p><dl>
<dt><code class="ce">WORD    Magic</code></dt>

<dd>Appears to be a signature WORD of some sort. Always appears to be set to 0x010B.</dd>

<dt><code class="ce">BYTE    MajorLinkerVersion</code></dt>

<dt><code class="ce">BYTE    MinorLinkerVersion</code></dt>

<dd>The version of the linker that produced this file. The numbers should be displayed as decimal values, rather than as hex. A typical linker version is 2.23.</dd>

<dt><code class="ce">DWORD   SizeOfCode</code></dt>

<dd>The combined and rounded-up size of all the code sections. Usually, most files only have one code section, so this field matches the size of the .text section. </dd>

<dt><code class="ce">DWORD   SizeOfInitializedData</code></dt>

<dd>This is supposedly the total size of all the sections that are composed of initialized data (not including code segments.)  However, it doesn't seem to be consistent with what appears in the file.</dd>

<dt><code class="ce">DWORD   SizeOfUninitializedData</code></dt>

<dd>The size of the sections that the loader commits space for in the virtual address space, but that don't take up any space in the disk file. These sections don't need to have specific values at program startup, hence the term uninitialized data. Uninitialized data usually goes into a section called .bss.</dd>

<dt><code class="ce">DWORD   AddressOfEntryPoint</code></dt>

<dd>The address where the loader will begin execution. This is an RVA, and usually can usually be found in the .text section. </dd>

<dt><code class="ce">DWORD   BaseOfCode</code></dt>

<dd>The RVA where the file's code sections begin. The code sections typically come before the data sections and after the PE header in memory. This RVA is usually 0x1000 in Microsoft Linker-produced EXEs. Borland's TLINK32 looks like it adds the image base to the RVA of the first code section and stores the result in this field.</dd>

<dt><code class="ce">DWORD   BaseOfData</code></dt>

<dd>The RVA where the file's data sections begin. The data sections typically come last in memory, after the PE header and the code sections.</dd>

<dt><code class="ce">DWORD   ImageBase</code></dt>

<dd>When the linker creates an executable, it assumes that the file will be memory-mapped to a specific location in memory. That address is stored in this field, assuming a load address allows linker optimizations to take place. If the file really is memory-mapped to that address by the loader, the code doesn't need any patching before it can be run. In executables produced for Windows NT, the default image base is 0x10000. For DLLs, the default is 0x400000. In Windows 95, the address 0x10000 can't be used to load 32-bit EXEs because it lies within a linear address region shared by all processes. Because of this, Microsoft has changed the default base address for Win32 executables to 0x400000. Older programs that were linked assuming a base address of 0x10000 will take longer to load under Windows 95 because the loader needs to apply the base relocations.</dd>

<dt><code class="ce">DWORD   SectionAlignment</code></dt>

<dd>When mapped into memory, each section is guaranteed to start at a virtual address that's a multiple of this value. For paging purposes, the default section alignment is 0x1000.</dd>

<dt><code class="ce">DWORD   FileAlignment</code></dt>

<dd>In the PE file, the raw data that comprises each section is guaranteed to start at a multiple of this value. The default value is 0x200 bytes, probably to ensure that sections always start at the beginning of a disk sector (which are also 0x200 bytes in length). This field is equivalent to the segment/resource alignment size in NE files. Unlike NE files, PE files typically don't have hundreds of sections, so the space wasted by aligning the file sections is almost always very small.</dd>

<dt><code class="ce">WORD    MajorOperatingSystemVersion</code></dt>

<dt><code class="ce">WORD    MinorOperatingSystemVersion</code></dt>

<dd>The minimum version of the operating system required to use this executable. This field is somewhat ambiguous since the subsystem fields (a few fields later) appear to serve a similar purpose. This field defaults to 1.0 in all Win32 EXEs to date.</dd>

<dt><code class="ce">WORD    MajorImageVersion</code></dt>

<dt><code class="ce">WORD    MinorImageVersion</code></dt>

<dd>A user-definable field. This allows you to have different versions of an EXE or DLL. You set these fields via the linker /VERSION switch. For example, "LINK /VERSION:2.0 myobj.obj".</dd>

<dt><code class="ce">WORD    MajorSubsystemVersion</code></dt>

<dt><code class="ce">WORD    MinorSubsystemVersion</code></dt>

<dd>Contains the minimum subsystem version required to run the executable. A typical value for this field is 3.10 (meaning Windows NT 3.1).</dd>

<dt><code class="ce">DWORD   Reserved1</code></dt>

<dd>Seems to always be 0.</dd>

<dt><code class="ce">DWORD   SizeOfImage</code></dt>

<dd>This appears to be the total size of the portions of the image that the loader has to worry about. It is the size of the region starting at the image base up to the end of the last section. The end of the last section is rounded up to the nearest multiple of the section alignment. </dd>

<dt><code class="ce">DWORD   SizeOfHeaders</code></dt>

<dd>The size of the PE header and the section (object) table. The raw data for the sections starts immediately after all the header components.</dd>

<dt><code class="ce">DWORD   CheckSum</code></dt>

<dd>Supposedly a CRC checksum of the file. As in other Microsoft executable formats, this field is ignored and set to 0. The one exception to this rule is for trusted services and these EXEs must have a valid checksum.</dd>

<dt><code class="ce">WORD    Subsystem</code></dt>

<dd>The type of subsystem that this executable uses for its user interface. WINNT.H defines the following values:
<div class="tablediv"><table class="dtTABLE">

<tr><td>
<blockquote class="dtBlock"><div>
NATIVE </div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
1</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
Doesn't require a subsystem (such as a  device driver)</div></blockquote>
</td></tr>

<tr><td>
<blockquote class="dtBlock"><div>
WINDOWS_GUI </div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
2</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
Runs in the Windows GUI subsystem</div></blockquote>
</td></tr>

<tr><td>
<blockquote class="dtBlock"><div>
WINDOWS_CUI </div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
3</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
Runs in the Windows character subsystem (a console app)</div></blockquote>
</td></tr>

<tr><td>
<blockquote class="dtBlock"><div>
OS2_CUI </div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
5</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
Runs in the OS/2 character subsystem (OS/2 1.x apps only)</div></blockquote>
</td></tr>

<tr><td>
<blockquote class="dtBlock"><div>
POSIX_CUI </div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
7</div></blockquote>
</td><td>
<blockquote class="dtBlock"><div>
Runs in the Posix character subsystem</div></blockquote>
</td></tr>
</table></div>
</dd>
</dl>

<p>

</p><dl>
<dt><code class="ce">WORD    DllCharacteristics</code></dt>

<dd>A set of flags indicating under which circumstances a DLL's initialization function (such as DllMain) will be called. This value appears to always be set to 0, yet the operating system still calls the DLL initialization function for all four events.</dd>
</dl>

<blockquote class="dtBlock"><div>
The following values are defined:</div></blockquote>
<div class="tablediv"><table class="dtTABLE">

<tr><td>1 </td><td> Call when DLL is first loaded into a process's address space</td></tr>

<tr><td>2  </td><td> Call when a thread terminates</td></tr>

<tr><td>4 </td><td> Call when a thread starts up</td></tr>

<tr><td>8 </td><td> Call when DLL exits</td></tr>
</table></div>

<p>

</p><dl>
<dt><code class="ce">DWORD   SizeOfStackReserve</code></dt>

<dd>The amount of virtual memory to reserve for the initial thread's stack. Not all of this memory is committed, however (see the next field). This field defaults to 0x100000 (1MB). If you specify 0 as the stack size to CreateThread, the resulting thread will also have a stack of this same size.</dd>

<dt><code class="ce">DWORD   SizeOfStackCommit</code></dt>

<dd>The amount of memory initially committed for the initial thread's stack. This field defaults to 0x1000 bytes (1 page) for the Microsoft Linker while TLINK32 makes it two pages. </dd>

<dt><code class="ce">DWORD   SizeOfHeapReserve</code></dt>

<dd>The amount of virtual memory to reserve for the initial process heap. This heap's handle can be obtained by calling GetProcessHeap. Not all of this memory is committed (see the next field).</dd>

<dt><code class="ce">DWORD   SizeOfHeapCommit</code></dt>

<dd>The amount of memory initially committed in the process heap. The default is one page.</dd>

<dt><code class="ce">DWORD   LoaderFlags</code></dt>

<dd>From WINNT.H, these appear to be fields related to debugging support. I've never seen an executable with either of these bits enabled, nor is it clear how to get the linker to set them. The following values are defined:
<div class="tablediv"><table class="dtTABLE">

<tr><td>1.</td><td>Invoke a breakpoint instruction before starting the process</td></tr>

<tr><td> 2.</td><td>Invoke a debugger on the process after it's been loaded</td></tr>
</table></div>

</dd>

<dt><code class="ce">DWORD   NumberOfRvaAndSizes</code></dt>

<dd>The number of entries in the DataDirectory array (below). This value is always set to 16 by the current tools.</dd>

<dt><code class="ce">IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] </code></dt>

<dd>An array of IMAGE_DATA_DIRECTORY structures. The initial array elements contain the starting RVA and sizes of important portions of the executable file. Some elements at the end of the array are currently unused. The first element of the array is always the address and size of the exported function table (if present). The second array entry is the address and size of the imported function table, and so on. For a complete list of defined array entries, see the IMAGE_DIRECTORY_ENTRY_XXX #defines in WINNT.H. This array allows the loader to quickly find a particular section of the image (for example, the imported function table), without needing to iterate through each of the images sections, comparing names as it goes along. Most array entries describe an entire section's data. However, the IMAGE_DIRECTORY_ENTRY_DEBUG element only encompasses a small portion of the bytes in the .rdata section.</dd>
</dl>

<h2 class="dtH1">The Section Table</h2>

<p>Between the PE header and the raw data for the image's sections lies the section table. The section table is essentially a phone book containing information about each section in the image. The sections in the image are sorted by their starting address (RVAs), rather than alphabetically.</p>

<p>Now I can better clarify what a section is. In an NE file, your program's code and data are stored in distinct "segments" in the file. Part of the NE header is an array of structures, one for each segment your program uses. Each structure in the array contains information about one segment. The information stored includes the segment's type (code or data), its size, and its location elsewhere in the file. In a PE file, the section table is analogous to the segment table in the NE file. Unlike an NE file segment table, though, a PE section table doesn't store a selector value for each code or data chunk. Instead, each section table entry stores an address where the file's raw data has been mapped into memory. While sections are analogous to 32-bit segments, they really aren't individual segments. They're just really memory ranges in a process's virtual address space.</p>

<p>Another area where PE files differ from NE files is how they manage the supporting data that your program doesn't use, but the operating system does; for example, the list of DLLs that the executable uses or the location of the fixup table. In an NE file, resources aren't considered segments. Even though they have selectors assigned to them, information about resources is not stored in the NE header's segment table. Instead, resources are relegated to a separate table towards the end of the NE header. Information about imported and exported functions also doesn't warrant its own segment; it's crammed into the NE header. </p>

<p>The story with PE files is different. Anything that might be considered vital code or data is stored in a full-fledged section. Thus, information about imported functions is stored in its own section, as is the table of functions that the module exports. The same goes for the relocation data. Any code or data that might be needed by either the program or the operating system gets its own section.</p>

<p>Before I discuss specific sections, I need to describe the data that the operating system manages the sections with. Immediately following the PE header in memory is an array of IMAGE_SECTION_HEADERs. The number of elements in this array is given in the PE header (the IMAGE_NT_HEADER.FileHeader.NumberOfSections field). I used PEDUMP to output the section table and all of the section's fields and attributes. Figure 5 shows the PEDUMP output of a section table for a typical EXE file, and Figure 6 shows the section table in an OBJ file.</p>

<p class="label"><strong>Table 4. A Typical Section Table from an EXE File </strong></p>


<div id="code-snippet-7" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_f0c7ac5e-e9e3-46b4-beff-53675581663e');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_f0c7ac5e-e9e3-46b4-beff-53675581663e" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
01 .text     VirtSize: 00005AFA  VirtAddr:  00001000
    raw data offs:   00000400  raw data size: 00005C00
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00009220  line #'s:      0000020C
    characteristics: 60000020
      CODE  MEM_EXECUTE  MEM_READ

  02 .bss      VirtSize: 00001438  VirtAddr:  00007000
    raw data offs:   00000000  raw data size: 00001600
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: C0000080
      UNINITIALIZED_DATA  MEM_READ  MEM_WRITE

  03 .rdata    VirtSize: 0000015C  VirtAddr:  00009000
    raw data offs:   00006000  raw data size: 00000200
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: 40000040
      INITIALIZED_DATA  MEM_READ

  04 .data     VirtSize: 0000239C  VirtAddr:  0000A000
    raw data offs:   00006200  raw data size: 00002400
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: C0000040
      INITIALIZED_DATA  MEM_READ  MEM_WRITE

  05 .idata    VirtSize: 0000033E  VirtAddr:  0000D000
    raw data offs:   00008600  raw data size: 00000400
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: C0000040
      INITIALIZED_DATA  MEM_READ  MEM_WRITE

  06 .reloc    VirtSize: 000006CE  VirtAddr:  0000E000
    raw data offs:   00008A00  raw data size: 00000800
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: 42000040
      INITIALIZED_DATA  MEM_DISCARDABLE  MEM_READ
  
</pre></div>
            
        </div>
    </div>
</div>


<p class="label"><strong>Table 5. A Typical Section Table from an OBJ File </strong></p>


<div id="code-snippet-8" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_395fce15-549f-4672-b0c0-b60ed570ad3a');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_395fce15-549f-4672-b0c0-b60ed570ad3a" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
01 .drectve  PhysAddr: 00000000  VirtAddr:  00000000
    raw data offs:   000000DC  raw data size: 00000026
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: 00100A00
      LNK_INFO  LNK_REMOVE

  02 .debug$S  PhysAddr: 00000026  VirtAddr:  00000000
    raw data offs:   00000102  raw data size: 000016D0
    relocation offs: 000017D2  relocations:   00000032
    line # offs:     00000000  line #'s:      00000000
    characteristics: 42100048
      INITIALIZED_DATA  MEM_DISCARDABLE  MEM_READ

  03 .data     PhysAddr: 000016F6  VirtAddr:  00000000
    raw data offs:   000019C6  raw data size: 00000D87
    relocation offs: 0000274D  relocations:   00000045
    line # offs:     00000000  line #'s:      00000000
    characteristics: C0400040
      INITIALIZED_DATA  MEM_READ  MEM_WRITE

  04 .text     PhysAddr: 0000247D  VirtAddr:  00000000
    raw data offs:   000029FF  raw data size: 000010DA
    relocation offs: 00003AD9  relocations:   000000E9
    line # offs:     000043F3  line #'s:      000000D9
    characteristics: 60500020
      CODE  MEM_EXECUTE  MEM_READ

  05 .debug$T  PhysAddr: 00003557  VirtAddr:  00000000
    raw data offs:   00004909  raw data size: 00000030
    relocation offs: 00000000  relocations:   00000000
    line # offs:     00000000  line #'s:      00000000
    characteristics: 42100048
      INITIALIZED_DATA  MEM_DISCARDABLE  MEM_READ
  
</pre></div>
            
        </div>
    </div>
</div>


<p>Each IMAGE_SECTION_HEADER has the format described in Figure 7. It's interesting to note what's missing from the information stored for each section. First off, notice that there's no indication of any PRELOAD attributes. The NE file format allows you to specify with the PRELOAD attribute which segments should be loaded at module load time. The OS/2® 2.0 LX format has something similar, allowing you to specify up to eight pages to preload. The PE format has nothing like this. Microsoft must be confident in the performance of Win32 demand-paged loading.</p>

<p class="label"><strong>Table 6. IMAGE_SECTION_HEADER Formats</strong>

</p><dl>
<dt><code class="ce">BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]</code></dt>

<dd>This is an 8-byte ANSI name (not UNICODE) that names the section. Most section names start with a . (such as ".text"), but this is not a requirement, as some PE documentation would have you believe. You can name your own sections with either the segment directive in assembly language, or with "#pragma data_seg" and "#pragma code_seg" in the Microsoft C/C++ compiler. It's important to note that if the section name takes up the full 8 bytes, there's no NULL terminator byte. If you're a printf devotee, you can use %.8s to avoid copying the name string to another buffer where you can NULL-terminate it.</dd>

<dt><code class="ce">union {</code></dt>

<dt><code class="ce">    DWORD   PhysicalAddress</code></dt>

<dt><code class="ce">    DWORD   VirtualSize</code></dt>

<dt><code class="ce">} Misc; </code></dt>

<dd>This field has different meanings, in EXEs or OBJs. In an EXE, it holds the actual size of the code or data. This is the size before rounding up to the nearest file alignment multiple. The SizeOfRawData field (seems a bit of a misnomer) later on in the structure holds the rounded up value. The Borland linker reverses the meaning of these two fields and appears to be correct. For OBJ files, this field indicates the physical address of the section. The first section starts at address 0. To find the physical address in an OBJ file of the next section, add the SizeOfRawData value to the physical address of the current section.</dd>

<dt><code class="ce">DWORD   VirtualAddress</code></dt>

<dd>In EXEs, this field holds the RVA to where the loader should map the section. To calculate the real starting address of a given section in memory, add the base address of the image to the section's VirtualAddress stored in this field. With Microsoft tools, the first section defaults to an RVA of 0x1000. In OBJs, this field is meaningless and is set to 0.</dd>

<dt><code class="ce">DWORD   SizeOfRawData</code></dt>

<dd>In EXEs, this field contains the size of the section after it's been rounded up to the file alignment size. For example, assume a file alignment size of 0x200. If the VirtualSize field from above says that the section is 0x35A bytes in length, this field will say that the section is 0x400 bytes long. In OBJs, this field contains the exact size of the section emitted by the compiler or assembler. In other words, for OBJs, it's equivalent to the VirtualSize field in EXEs.</dd>

<dt><code class="ce">DWORD   PointerToRawData</code></dt>

<dd>This is the file-based offset of where the raw data emitted by the compiler or assembler can be found. If your program memory maps a PE or COFF file itself (rather than letting the operating system load it), this field is more important than the VirtualAddress field. You'll have a completely linear file mapping in this situation, so you'll find the data for the sections at this offset, rather than at the RVA specified in the VirtualAddress field.</dd>

<dt><code class="ce">DWORD   PointerToRelocations</code></dt>

<dd>In OBJs, this is the file-based offset to the relocation information for this section. The relocation information for each OBJ section immediately follows the raw data for that section. In EXEs, this field (and the subsequent field) are meaningless, and set to 0. When the linker creates the EXE, it resolves most of the fixups, leaving only base address relocations and imported functions to be resolved at load time. The information about base relocations and imported functions is kept in their own sections, so there's no need for an EXE to have per-section relocation data following the raw section data.</dd>

<dt><code class="ce">DWORD   PointerToLinenumbers</code></dt>

<dd>This is the file-based offset of the line number table. A line number table correlates source file line numbers to the addresses of the code generated for a given line. In modern debug formats like the CodeView format, line number information is stored as part of the debug information. In the COFF debug format, however, the line number information is stored separately from the symbolic name/type information. Usually, only code sections (such as .text) have line numbers. In EXE files, the line numbers are collected towards the end of the file, after the raw data for the sections. In OBJ files, the line number table for a section comes after the raw section data and the relocation table for that section. </dd>

<dt><code class="ce">WORD    NumberOfRelocations</code></dt>

<dd>The number of relocations in the relocation table for this section (the PointerToRelocations field from above). This field seems relevant only for OBJ files.</dd>

<dt><code class="ce">WORD    NumberOfLinenumbers</code></dt>

<dd>The number of line numbers in the line number table for this section (the PointerToLinenumbers field from above).</dd>

<dt><code class="ce">DWORD   Characteristics</code></dt>

<dd>What most programmers call flags, the COFF/PE format calls characteristics. This field is a set of flags that indicate the section's attributes (such as code/data, readable, or writeable,). For a complete list of all possible section attributes, see the IMAGE_SCN_XXX_XXX #defines in WINNT.H. Some of the more important flags are shown below:</dd>
</dl>

<blockquote class="dtBlock"><div>
0x00000020 This section contains code. Usually set in conjunction with the executable flag (0x80000000).</div></blockquote>

<blockquote class="dtBlock"><div>
0x00000040 This section contains initialized data. Almost all sections except executable and the .bss section have this flag set.</div></blockquote>

<blockquote class="dtBlock"><div>
0x00000080 This section contains uninitialized data (for example, the .bss section).</div></blockquote>

<blockquote class="dtBlock"><div>
0x00000200 This section contains comments or some other type of information. A typical use of this section is the .drectve section emitted by the compiler, which contains commands for the linker. </div></blockquote>

<blockquote class="dtBlock"><div>
0x00000800 This section's contents shouldn't be put in the final EXE file. These sections are used by the compiler/assembler to pass information to the linker.</div></blockquote>

<blockquote class="dtBlock"><div>
0x02000000 This section can be discarded, since it's not needed by the process once it's been loaded. The most common discardable section is the base relocations (.reloc).</div></blockquote>

<blockquote class="dtBlock"><div>
0x10000000 This section is shareable. When used with a DLL, the data in this section will be shared among all processes using the DLL. The default is for data sections to be nonshared, meaning that each process using a DLL gets its own copy of this section's data. In more technical terms, a shared section tells the memory manager to set the page mappings for this section such that all processes using the DLL refer to the same physical page in memory. To make a section shareable, use the SHARED attribute at link time. For example</div></blockquote>


<div id="code-snippet-9" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_d4530bf4-aab1-44e9-b406-84775b2a42bb');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_d4530bf4-aab1-44e9-b406-84775b2a42bb" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
LINK /SECTION:MYDATA,RWS ...

</pre></div>
            
        </div>
    </div>
</div>


<blockquote class="dtBlock"><div>
tells the linker that the section called MYDATA should be readable, writeable, and shared.</div></blockquote>

<blockquote class="dtBlock"><div>
0x20000000 This section is executable. This flag is usually set whenever the "contains code" flag (0x00000020) is set.</div></blockquote>

<blockquote class="dtBlock"><div>
0x40000000 This section is readable. This flag is almost always set for sections in EXE files.</div></blockquote>

<blockquote class="dtBlock"><div>
0x80000000 The section is writeable. If this flag isn't set in an EXE's section, the loader should mark the memory mapped pages as read-only or execute-only. Typical sections with this attribute are .data and .bss. Interestingly, the .idata section also has this attribute set.</div></blockquote>

<p>Also missing from the PE format is the notion of page tables. The OS/2 equivalent of an IMAGE_SECTION_HEADER in the LX format doesn't point directly to where the code or data for a section can be found in the file. Instead, it refers to a page lookup table that specifies attributes and the locations of specific ranges of pages within a section. The PE format dispenses with all that, and guarantees that a section's data will be stored contiguously within the file. Of the two formats, the LX method may allow more flexibility, but the PE style is significantly simpler and easier to work with. Having written file dumpers for both formats, I can vouch for this!</p>

<p>Another welcome change in the PE format is that the locations of items are stored as simple DWORD offsets. In the NE format, the location of almost everything is stored as a sector value. To find the real offset, you need to first look up the alignment unit size in the NE header and convert it to a sector size (typically 16 or 512 bytes). You then need to multiply the sector size by the specified sector offset to get an actual file offset. If by chance something isn't stored as a sector offset in an NE file, it is probably stored as an offset relative to the NE header. Since the NE header isn't at the beginning of the file, you need to drag around the file offset of the NE header in your code. All in all, the PE format is much easier to work with than the NE, LX, or LE formats (assuming you can use memory-mapped files).</p>

<h2 class="dtH1">Common Sections</h2>

<p>Having seen what sections are in general and where they're located, let's look at the common sections that you'll find in EXE and OBJ files. The list is by no means complete, but includes the sections you encounter every day (even if you're not aware of it).</p>

<p>The .text section is where all general-purpose code emitted by the compiler or assembler ends up. Since PE files run in 32-bit mode and aren't restricted to 16-bit segments, there's no reason to break the code from separate source files into separate sections. Instead, the linker concatenates all the .text sections from the various OBJs into one big .text section in the EXE. If you use Borland C++ the compiler emits its code to a segment named CODE. PE files produced with Borland C++ have a section named CODE rather than one called .text. I'll explain this in a minute.</p>

<p>It was somewhat interesting to me to find out that there was additional code in the .text section beyond what I created with the compiler or used from the run-time libraries. In a PE file, when you call a function in another module (for example, GetMessage in USER32.DLL), the CALL instruction emitted by the compiler doesn't transfer control directly to the function in the DLL (see Figure 8). Instead, the call instruction transfers control to a </p>


<div id="code-snippet-10" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_743988d8-efa5-4a49-86e8-26ad4a254bd8');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_743988d8-efa5-4a49-86e8-26ad4a254bd8" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
JMP DWORD PTR [XXXXXXXX]
  
</pre></div>
            
        </div>
    </div>
</div>


<p>instruction that's also in the .text section. The JMP instruction indirects through a DWORD variable in the .idata section. This .idata section DWORD contains the real address of the operating system function entry point. After thinking about this for a while, I came to understand why DLL calls are implemented this way. By funneling all calls to a given DLL function through one location, the loader doesn't need to patch every instruction that calls a DLL. All the PE loader has to do is put the correct address of the target function into the DWORD in the .idata section. No call instructions need to be patched. This is in marked contrast to NE files, where each segment contains a list of fixups that need to be applied to the segment. If the segment calls a given DLL function 20 times, the loader must write the address of that function 20 times into the segment. The downside to the PE method is that you can't initialize a variable with the true address of a DLL function. For example, you would think that something like</p>

<p class="fig"><code><img id="peeringpe2" alt="ms809762.peeringpe2(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC38527.gif" title="ms809762.peeringpe2(en-us,MSDN.10).gif" xmlns="" /></code></p>

<p class="label"><strong>Figure 2. Calling a function in another module</strong></p>


<div id="code-snippet-11" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_6c039abe-0ff2-48b6-a59a-bd5c5820fafc');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_6c039abe-0ff2-48b6-a59a-bd5c5820fafc" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
FARPROC pfnGetMessage = GetMessage;

</pre></div>
            
        </div>
    </div>
</div>


<p>would put the address of GetMessage into the variable pfnGetMessage. In 16-bit Windows, this works, while in Win32 it doesn't. In Win32, the variable pfnGetMessage will end up holding the address of the JMP DWORD PTR [XXXXXXXX] thunk that I mentioned earlier. If you wanted to call through the function pointer, things would work as you'd expect. However, if you want to read the bytes at the beginning of GetMessage, you're out of luck (unless you do additional work to follow the .idata "pointer" yourself). I'll come back to this topic later, in the discussion of the import table.</p>

<p>Although Borland could have had the compiler emit segments with a name of .text, it chose a default segment name of CODE. To determine a section name in the PE file, the Borland linker (TLINK32.EXE) takes the segment name from the OBJ file and truncates it to 8 characters (if necessary). </p>

<p>While the difference in the section names is a small matter, there is a more important difference in how Borland PE files link to other modules. As I mentioned in the .text description, all calls to OBJs go through a JMP DWORD PTR [XXXXXXXX] thunk. Under the Microsoft system, this thunk comes to the EXE from the .text section of an import library. Because the library manager (LIB32) creates the import library (and the thunk) when you link the external DLL, the linker doesn't have to "know" how to generate these thunks itself. The import library is really just some more code and data to link into the PE file. </p>

<p>The Borland system of dealing with imported functions is simply an extension of the way things were done for 16-bit NE files. The import libraries that the Borland linker uses are really just a list of function names along with the name of the DLL they're in. TLINK32 is therefore responsible for determining which fixups are to external DLLs, and generating an appropriate JMP DWORD PTR [XXXXXXXX] thunk for it. TLINK32 stores the thunks that it creates in a section named .icode.</p>

<p>Just as .text is the default section for code, the .data section is where your initialized data goes. This data consists of global and static variables that are initialized at compile time. It also includes string literals. The linker combines all the .data sections from the OBJ and LIB files into one .data section in the EXE. Local variables are located on a thread's stack, and take no room in the .data or .bss sections.</p>

<p>The .bss section is where any uninitialized static and global variables are stored. The linker combines all the .bss sections in the OBJ and LIB files into one .bss section in the EXE. In the section table, the RawDataOffset field for the .bss section is set to 0, indicating that this section doesn't take up any space in the file. TLINK doesn't emit this section. Instead it extends the virtual size of the DATA section.</p>

<p>.CRT is another initialized data section utilized by the Microsoft C/C++ run-time libraries (hence the name). Why this data couldn't go into the standard .data section is beyond me.</p>

<p>The .rsrc section contains all the resources for the module. In the early days of Windows NT, the RES file output of the 16-bit RC.EXE wasn't in a format that the Microsoft PE linker could understand. The CVTRES program converted these RES files into a COFF-format OBJ, placing the resource data into a .rsrc section within the OBJ. The linker could then treat the resource OBJ as just another OBJ to link in, allowing the linker to not "know" anything special about resources. More recent linkers from Microsoft appear to be able to process RES files directly.</p>

<p>The .idata section contains information about functions (and data) that the module imports from other DLLs. This section is equivalent to an NE file's module reference table. A key difference is that each function that a PE file imports is specifically listed in this section. To find the equivalent information in an NE file, you'd have to go digging through the relocations at the end of the raw data for each of the segments. </p>

<p>The .edata section is a list of the functions and data that the PE file exports for other modules. Its NE file equivalent is the combination of the entry table, the resident names table, and the nonresident names table. Unlike in 16-bit Windows, there's seldom a reason to export anything from an EXE file, so you usually only see .edata sections in DLLs. When using Microsoft tools, the data in the .edata section comes to the PE file via the EXP file. Put another way, the linker doesn't generate this information on its own. Instead, it relies on the library manager (LIB32) to scan the OBJ files and create the EXP file that the linker adds to its list of modules to link. Yes, that's right!  Those pesky EXP files are really just OBJ files with a different extension.</p>

<p>The .reloc section holds a table of base relocations. A base relocation is an adjustment to an instruction or initialized variable value that's needed if the loader couldn't load the file where the linker assumed it would. If the loader is able to load the image at the linker's preferred base address, the loader completely ignores the relocation information in this section. If you want to take a chance and hope that the loader can always load the image at the assumed base address, you can tell the linker to strip this information with the /FIXED option. While this may save space in the executable file, it may cause the executable not to work on other Win32-based implementations. For example, say you built an EXE for Windows NT and based the EXE at 0x10000. If you told the linker to strip the relocations, the EXE wouldn't run under Windows 95, where the address 0x10000 is already in use.</p>

<p>It's important to note that the JMP and CALL instructions that the compiler generates use offsets relative to the instruction, rather than actual offsets in the 32-bit flat segment. If the image needs to be loaded somewhere other than where the linker assumed for a base address, these instructions don't need to change, since they use relative addressing. As a result, there are not as many relocations as you might think. Relocations are usually only needed for instructions that use a 32-bit offset to some data. For example, let's say you had the following global variable declarations:</p>


<div id="code-snippet-12" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_82cb7bd0-7776-42b2-8cd6-fbff95946036');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_82cb7bd0-7776-42b2-8cd6-fbff95946036" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
int i;
int *ptr = &amp;i;
  
</pre></div>
            
        </div>
    </div>
</div>


<p>If the linker assumed an image base of 0x10000, the address of the variable i will end up containing something like 0x12004. At the memory used to hold the pointer "ptr", the linker will have written out 0x12004, since that's the address of the variable i. If the loader for whatever reason decided to load the file at a base address of 0x70000, the address of i would be 0x72004. The .reloc section is a list of places in the image where the difference between the linker assumed load address and the actual load address needs to be factored in.</p>

<p>When you use the compiler directive _ _declspec(thread), the data that you define doesn't go into either the .data or .bss sections. It ends up in the .tls section, which refers to "thread local storage," and is related to the TlsAlloc family of Win32 functions. When dealing with a .tls section, the memory manager sets up the page tables so that whenever a process switches threads, a new set of physical memory pages is mapped to the .tls section's address space. This permits per-thread global variables. In most cases, it is much easier to use this mechanism than to allocate memory on a per-thread basis and store its pointer in a TlsAlloc'ed slot.</p>

<p>There's one unfortunate note that must be added about the .tls section and _ _declspec(thread) variables. In Windows NT and Windows 95, this thread local storage mechanism won't work in a DLL if the DLL is loaded dynamically by LoadLibrary. In an EXE or an implicitly loaded DLL, everything works fine. If you can't implicitly link to the DLL, but need per-thread data, you'll have to fall back to using TlsAlloc and TlsGetValue with dynamically allocated memory.</p>

<p>Although the .rdata section usually falls between the .data and .bss sections, your program generally doesn't see or use the data in this section. The .rdata section is used for at least two things. First, in Microsoft linker-produced EXEs, the .rdata section holds the debug directory, which is only present in EXE files. (In TLINK32 EXEs, the debug directory is in a section named .debug.) The debug directory is an array of IMAGE_DEBUG_DIRECTORY structures. These structures hold information about the type, size, and location of the various types of debug information stored in the file. Three main types of debug information appear: CodeView®, COFF, and FPO. Figure 9 shows the PEDUMP output for a typical debug directory.</p>

<p class="label"><strong>Table 7. A Typical Debug Directory </strong></p>
<div class="tablediv"><table class="dtTABLE">

<tr><td><strong>Type</strong></td><td><strong>Size</strong></td><td><strong>Address</strong></td><td><strong>FilePtr</strong></td><td><strong>Charactr</strong></td><td><strong>TimeData</strong></td><td><strong>Version</strong></td><td> </td></tr>

<tr><td>COFF</td><td>000065C5</td><td>00000000</td><td>00009200</td><td>00000000</td><td>2CF8CF3D</td><td> </td><td>0.00</td></tr>

<tr><td>???</td><td>00000114</td><td>00000000</td><td>0000F7C8</td><td>00000000</td><td>2CF8CF3D</td><td> </td><td>0.00</td></tr>

<tr><td>FPO</td><td>000004B0</td><td>00000000</td><td>0000F8DC</td><td>00000000</td><td>2CF8CF3D</td><td> </td><td>0.00</td></tr>

<tr><td>CODEVIEW</td><td>0000B0B4</td><td>00000000</td><td>0000FD8C</td><td>00000000</td><td>2CF8CF3D</td><td> </td><td>0.00</td></tr>
</table></div>

<p>The debug directory isn't necessarily found at the beginning of the .rdata section. To find the start of the debug directory table, use the RVA in the seventh entry (IMAGE_DIRECTORY_ENTRY_DEBUG) of the data directory. The data directory is at the end of the PE header portion of the file. To determine the number of entries in the Microsoft linker-generated debug directory, divide the size of the debug directory (found in the size field of the data directory entry) by the size of an IMAGE_DEBUG_DIRECTORY structure. TLINK32 emits a simple count, usually 1. The PEDUMP sample program demonstrates this.</p>

<p>The other useful portion of an .rdata section is the description string. If you specified a DESCRIPTION entry in your program's DEF file, the specified description string appears in the .rdata section. In the NE format, the description string is always the first entry of the nonresident names table. The description string is intended to hold a useful text string describing the file. Unfortunately, I haven't found an easy way to find it. I've seen PE files that had the description string before the debug directory, and other files that had it after the debug directory. I'm not aware of any consistent method of finding the description string (or even if it's present at all).</p>

<p>These .debug$S and .debug$T sections only appear in OBJs. They store the CodeView symbol and type information. The section names are derived from the segment names used for this purpose by previous 16-bit compilers ($$SYMBOLS and $$TYPES). The sole purpose of the .debug$T section is to hold the pathname to the PDB file that contains the CodeView information for all the OBJs in the project. The linker reads in the PDB and uses it to create portions of the CodeView information that it places at the end of the finished PE file.</p>

<p>The .drective section only appears in OBJ files. It contains text representations of commands for the linker. For example, in any OBJ I compile with the Microsoft compiler, the following strings appear in the .drectve section: </p>


<div id="code-snippet-13" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_09607db6-85f0-4d77-968c-c965f11caae4');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_09607db6-85f0-4d77-968c-c965f11caae4" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
-defaultlib:LIBC -defaultlib:OLDNAMES
  
</pre></div>
            
        </div>
    </div>
</div>


<p>When you use _ _declspec(export) in your code, the compiler simply emits the command-line equivalent into the .drectve section (for instance, "-export:MyFunction").</p>

<p>In playing around with PEDUMP, I've encountered other sections from time to time. For instance, in the Windows 95 KERNEL32.DLL, there are LOCKCODE and LOCKDATA sections. Presumably these are sections that will get special paging treatment so that they're never paged out of memory. </p>

<p>There are two lessons to be learned from this. First, don't feel constrained to use only the standard sections provided by the compiler or assembler. If you need a separate section for some reason, don't hesitate to create your own. In the C/C++ compiler, use the #pragma code_seg and #pragma data_seg. In assembly language, just create a 32-bit segment (which becomes a section) with a name different from the standard sections. If using TLINK32, you must use a different class or turn off code segment packing. The other thing to remember is that section names that are out of the ordinary can often give a deeper insight into the purpose and implementation of a particular PE file.</p>

<h2 class="dtH1">PE File Imports</h2>

<p>Earlier, I described how function calls to outside DLLs don't call the DLL directly. Instead, the CALL instruction goes to a JMP DWORD PTR [XXXXXXXX] instruction somewhere in the executable's .text section (or .icode section if you're using Borland C++). The address that the JMP instruction looks up and transfers control to is the real target address. The PE file's .idata section contains the information necessary for the loader to determine the addresses of the target functions and patch them into the executable image.</p>

<p>The .idata section (or import table, as I prefer to call it) begins with an array of IMAGE_IMPORT_DESCRIPTORs. There is one IMAGE_IMPORT_DESCRIPTOR for each DLL that the PE file implicitly links to. There's no field indicating the number of structures in this array. Instead, the last element of the array is indicated by an IMAGE_IMPORT_DESCRIPTOR that has fields filled with NULLs. The format of an IMAGE_IMPORT_DESCRIPTOR is shown in Figure 10.</p>

<p class="label"><strong>Table 8. IMAGE_IMPORT_DESCRIPTOR Format</strong>

</p><dl>
<dt><code class="ce">DWORD   Characteristics</code></dt>

<dd>At one time, this may have been a set of flags. However, Microsoft changed its meaning and never bothered to update WINNT.H. This field is really an offset (an RVA) to an array of pointers. Each of these pointers points to an IMAGE_IMPORT_BY_NAME structure. </dd>

<dt><code class="ce">DWORD   TimeDateStamp</code></dt>

<dd>The time/date stamp indicating when the file was built. </dd>

<dt><code class="ce">DWORD  ForwarderChain</code></dt>

<dd>This field relates to forwarding. Forwarding involves one DLL sending on references to one of its functions to another DLL. For example, in Windows NT, NTDLL.DLL appears to forward some of its exported functions to KERNEL32.DLL. An application may think it's calling a function in NTDLL.DLL, but it actually ends up calling into KERNEL32.DLL. This field contains an index into FirstThunk array (described momentarily). The function indexed by this field will be forwarded to another DLL. Unfortunately, the format of how a function is forwarded isn't documented, and examples of forwarded functions are hard to find.</dd>

<dt><code class="ce">DWORD   Name</code></dt>

<dd>This is an RVA to a NULL-terminated ASCII string containing the imported DLL's name. Common examples are "KERNEL32.DLL" and "USER32.DLL".</dd>

<dt><code class="ce">PIMAGE_THUNK_DATA FirstThunk</code></dt>

<dd>This field is an offset (an RVA) to an IMAGE_THUNK_DATA union. In almost every case, the union is interpreted as a pointer to an IMAGE_IMPORT_BY_NAME structure. If the field isn't one of these pointers, then it's supposedly treated as an export ordinal value for the DLL that's being imported. It's not clear from the  documentation if you really can import a function by ordinal rather than by name. </dd>
</dl>

<p>The important parts of an IMAGE_IMPORT_DESCRIPTOR are the imported DLL name and the two arrays of IMAGE_IMPORT_BY_NAME pointers. In the EXE file, the two arrays (pointed to by the Characteristics and FirstThunk fields) run parallel to each other, and are terminated by a NULL pointer entry at the end of each array. The pointers in both arrays point to an IMAGE_IMPORT_BY_NAME structure. Figure 11 shows the situation graphically. Figure 12 shows the PEDUMP output for an imports table.</p>

<p class="fig"><code><img id="peeringpe3" alt="ms809762.peeringpe3(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC112823.gif" title="ms809762.peeringpe3(en-us,MSDN.10).gif" xmlns="" /></code></p>

<p class="label"><strong>Figure 3. Two parallel arrays of pointers</strong></p>

<p class="label"><strong>Table 9. Imports Table from an EXE File</strong></p>


<div id="code-snippet-14" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_1da198c2-3049-47ff-9d08-a5e338f35284');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_1da198c2-3049-47ff-9d08-a5e338f35284" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
GDI32.dll
  Hint/Name Table: 00013064
  TimeDateStamp:   2C51B75B
  ForwarderChain:  FFFFFFFF
  First thunk RVA: 00013214
  Ordn  Name
    48  CreatePen
    57  CreateSolidBrush
    62  DeleteObject
   160  GetDeviceCaps
    //  Rest of table omitted...

  KERNEL32.dll
  Hint/Name Table: 0001309C
  TimeDateStamp:   2C4865A0
  ForwarderChain:  00000014
  First thunk RVA: 0001324C
  Ordn  Name
    83  ExitProcess
   137  GetCommandLineA
   179  GetEnvironmentStrings
   202  GetModuleHandleA
    //  Rest of table omitted...

  SHELL32.dll
  Hint/Name Table: 00013138
  TimeDateStamp:   2C41A383
  ForwarderChain:  FFFFFFFF
  First thunk RVA: 000132E8
  Ordn  Name
    46  ShellAboutA

  USER32.dll
  Hint/Name Table: 00013140
  TimeDateStamp:   2C474EDF
  ForwarderChain:  FFFFFFFF
  First thunk RVA: 000132F0
  Ordn  Name
    10  BeginPaint
    35  CharUpperA
    39  CheckDlgButton
    40  CheckMenuItem
  
    //  Rest of table omitted...

</pre></div>
            
        </div>
    </div>
</div>


<p>There is one IMAGE_IMPORT_BY_NAME structure for each function that the PE file imports. An IMAGE_IMPORT_BY_NAME structure is very simple, and looks like this:</p>


<div id="code-snippet-15" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_e7cbd8d1-f3bf-4377-afb8-1f1e84be5644');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_e7cbd8d1-f3bf-4377-afb8-1f1e84be5644" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
WORD    Hint;
BYTE    Name[?];

</pre></div>
            
        </div>
    </div>
</div>


<p>The first field is the best guess as to what the export ordinal for the imported function is. Unlike with NE files, this value doesn't have to be correct. Instead, the loader uses it as a suggested starting value for its binary search for the exported function. Next is an ASCIIZ string with the name of the imported function.</p>

<p>Why are there two parallel arrays of pointers to the IMAGE_IMPORT_BY_NAME structures?  The first array (the one pointed at by the Characteristics field) is left alone, and never modified. It's sometimes called the hint-name table. The second array (pointed at by the FirstThunk field) is overwritten by the PE loader. The loader iterates through each pointer in the array and finds the address of the function that each IMAGE_IMPORT_BY_NAME structure refers to. The loader then overwrites the pointer to IMAGE_IMPORT_BY_NAME with the found function's address. The [XXXXXXXX] portion of the JMP DWORD PTR [XXXXXXXX] thunk refers to one of the entries in the FirstThunk array. Since the array of pointers that's overwritten by the loader eventually holds the addresses of all the imported functions, it's called the Import Address Table.</p>

<p>For you Borland users, there's a slight twist to the above description. A PE file produced by TLINK32 is missing one of the arrays. In such an executable, the Characteristics field in the IMAGE_IMPORT_DESCRIPTOR (aka the hint-name array) is 0. Therefore, only the array that's pointed at by the FirstThunk field (the Import Address Table) is guaranteed to exist in all PE files. The story would end here, except that I ran into an interesting problem when writing PEDUMP. In the never ending search for optimizations, Microsoft "optimized" the thunk array in the system DLLs for Windows NT (KERNEL32.DLL and so on). In this optimization, the pointers in the array don't point to an IMAGE_IMPORT_BY_NAME structure—rather, they already contain the address of the imported function. In other words, the loader doesn't need to look up function addresses and overwrite the thunk array with the imported function's addresses. This causes a problem for PE dumping programs that are expecting the array to contain pointers to IMAGE_IMPORT_BY_NAME structures. You might be thinking, "But Matt, why don't you just use the hint-name table array?" That would be an ideal solution, except that the hint-name table array doesn't exist in Borland files. The PEDUMP program handles all these situations, but the code is understandably messy.</p>

<p>Since the import address table is in a writeable section, it's relatively easy to intercept calls that an EXE or DLL makes to another DLL. Simply patch the appropriate import address table entry to point at the desired interception function. There's no need to modify any code in either the caller or callee images. What could be easier?</p>

<p>It's interesting to note that in Microsoft-produced PE files, the import table is not something wholly synthesized by the linker. All the pieces necessary to call a function in another DLL reside in an import library. When you link a DLL, the library manager (LIB32.EXE or LIB.EXE) scans the OBJ files being linked and creates an import library. This import library is completely different from the import libraries used by 16-bit NE file linkers. The import library that the 32-bit LIB produces has a .text section and several .idata$ sections. The .text section in the import library contains the JMP DWORD PTR [XXXXXXXX] thunk, which has a name stored for it in the OBJ's symbol table. The name of the symbol is identical to the name of the function being exported by the DLL (for example, _Dispatch_Message@4). One of the .idata$ sections in the import library contains the DWORD that the thunk dereferences through. Another of the .idata$ sections has a space for the hint ordinal followed by the imported function's name. These two fields make up an IMAGE_IMPORT_BY_NAME structure. When you later link a PE file that uses the import library, the import library's sections are added to the list of sections from your OBJs that the linker needs to process. Since the thunk in the import library has the same name as the function being imported, the linker assumes the thunk is really the imported function, and fixes up calls to the imported function to point at the thunk. The thunk in the import library is essentially "seen" as the imported function.</p>

<p>Besides providing the code portion of an imported function thunk, the import library provides the pieces of the PE file's .idata section (or import table). These pieces come from the various .idata$ sections that the library manager put into the import library. In short, the linker doesn't really know the differences between imported functions and functions that appear in a different OBJ file. The linker just follows its preset rules for building and combining sections, and everything falls into place naturally.</p>

<h2 class="dtH1">PE File Exports</h2>

<p>The opposite of importing a function is exporting a function for use by EXEs or other DLLs. A PE file stores information about its exported functions in the .edata section. Generally, Microsoft linker-generated PE EXE files don't export anything, so they don't have an .edata section. Borland's TLINK32 always exports at least one symbol from an EXE. Most DLLs do export functions and have an .edata section. The primary components of an .edata section (aka the export table) are tables of function names, entry point addresses, and export ordinal values. In an NE file, the equivalents of an export table are the entry table, the resident names table, and the nonresident names table. These tables are stored as part of the NE header, rather than in distinct segments or resources.</p>

<p>At the start of an .edata section is an IMAGE_EXPORT_DIRECTORY structure (see Table 10). This structure is immediately followed by data pointed to by fields in the structure. </p>

<p class="label"><strong>Table 10. IMAGE_EXPORT_DIRECTORY Format</strong>

</p><dl>
<dt><code class="ce">DWORD   Characteristics</code></dt>

<dd>This field appears to be unused and is always set to 0.</dd>

<dt><code class="ce">DWORD   TimeDateStamp</code></dt>

<dd>The time/date stamp indicating when this file was created.</dd>

<dt><code class="ce">WORD    MajorVersion</code></dt>

<dt><code class="ce">WORD    MinorVersion</code></dt>

<dd>These fields appear to be unused and are set to 0.</dd>

<dt><code class="ce">DWORD   Name</code></dt>

<dd>The RVA of an ASCIIZ string with the name of this DLL. </dd>

<dt><code class="ce">DWORD   Base</code></dt>

<dd>The starting ordinal number for exported functions. For example, if the file exports functions with ordinal values of 10, 11, and 12, this field contains 10. To obtain the exported ordinal for a function, you need to add this value to the appropriate element of the AddressOfNameOrdinals array. </dd>

<dt><code class="ce">DWORD   NumberOfFunctions</code></dt>

<dd>The number of elements in the AddressOfFunctions array. This value is also the number of functions exported by this module. Theoretically, this value could be different than the NumberOfNames field (next), but actually they're always the same.</dd>

<dt><code class="ce">DWORD   NumberOfNames</code></dt>

<dd>The number of elements in the AddressOfNames array. This value seems always to be identical to the NumberOfFunctions field, and so is the number of exported functions.</dd>

<dt><code class="ce">PDWORD  *AddressOfFunctions</code></dt>

<dd>This field is an RVA and points to an array of function addresses. The function addresses are the entry points (RVAs) for each exported function in this module.</dd>

<dt><code class="ce">PDWORD  *AddressOfNames</code></dt>

<dd>This field is an RVA and points to an array of string pointers. The strings are the names of the exported functions in this module.</dd>

<dt><code class="ce">PWORD   *AddressOfNameOrdinals</code></dt>

<dd>This field is an RVA and points to an array of WORDs. The WORDs are the export ordinals of all the exported functions in this module. However, don't forget to add in the starting ordinal number specified in the Base field.</dd>
</dl>

<p>The layout of the export table is somewhat odd (see Figure 4 and Table 10). As I mentioned earlier, the requirements for exporting a function are a name, an address, and an export ordinal. You'd think that the designers of the PE format would have put all three of these items into a structure, and then have an array of these structures. Instead, each component of an exported entry is an element in an array. There are three of these arrays (AddressOfFunctions, AddressOfNames, AddressOfNameOrdinals), and they are all parallel to one another. To find all the information about the fourth function, you need to look up the fourth element in each array. </p>

<p class="fig"><code><img id="peeringpe4" alt="ms809762.peeringpe4(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC60608.gif" title="ms809762.peeringpe4(en-us,MSDN.10).gif" xmlns="" /></code></p>

<p class="label"><strong>Figure 4. Export table layout</strong></p>

<p class="label"><strong>Table 11. Typical Exports Table from an EXE File</strong></p>


<div id="code-snippet-16" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_de7e7bc4-2150-4431-985c-e7c560ba780b');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_de7e7bc4-2150-4431-985c-e7c560ba780b" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
Name:            KERNEL32.dll
  Characteristics: 00000000
  TimeDateStamp:   2C4857D3
  Version:         0.00
  Ordinal base:    00000001
  # of functions:  0000021F
  # of Names:      0000021F

  Entry Pt  Ordn  Name
  00005090     1  AddAtomA
  00005100     2  AddAtomW
  00025540     3  AddConsoleAliasA
  00025500     4  AddConsoleAliasW
  00026AC0     5  AllocConsole
  00001000     6  BackupRead
  00001E90     7  BackupSeek
  00002100     8  BackupWrite
  0002520C     9  BaseAttachCompleteThunk
  00024C50    10  BasepDebugDump
  // Rest of table omitted...

</pre></div>
            
        </div>
    </div>
</div>


<p>Incidentally, if you dump out the exports from the Windows NT system DLLs (for example, KERNEL32.DLL and USER32.DLL), you'll note that in many cases there are two functions that only differ by one character at the end of the name, for instance CreateWindowExA and CreateWindowExW. This is how UNICODE support is implemented transparently. The functions that end with A are the ASCII (or ANSI) compatible functions, while those ending in W are the UNICODE version of the function. In your code, you don't explicitly specify which function to call. Instead, the appropriate function is selected in WINDOWS.H, via preprocessor #ifdefs. This excerpt from the Windows NT WINDOWS.H shows an example of how this works:</p>


<div id="code-snippet-17" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_4519b63f-364c-4c83-9092-e5cd597b9cc9');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_4519b63f-364c-4c83-9092-e5cd597b9cc9" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
#ifdef UNICODE
#define DefWindowProc  DefWindowProcW
#else
#define DefWindowProc  DefWindowProcA
#endif // !UNICODE
  
</pre></div>
            
        </div>
    </div>
</div>


<h2 class="dtH1">PE File Resources</h2>

<p>Finding resources in a PE file is quite a bit more complicated than in an NE file. The formats of the individual resources (for example, a menu) haven't changed significantly but you need to traverse a strange hierarchy to find them.</p>

<p>Navigating the resource directory hierarchy is like navigating a hard disk. There's a master directory (the root directory), which has subdirectories. The subdirectories have subdirectories of their own that may point to the raw resource data for things like dialog templates. In the PE format, both the root directory of the resource directory hierarchy and all of its subdirectories are structures of type IMAGE_RESOURCE_DIRECTORY (see Table 12). </p>

<p class="label"><strong>Table 12. IMAGE_RESOURCE_DIRECTORY Format</strong>

</p><dl>
<dt><code class="ce">DWORD   Characteristics</code></dt>

<dd>Theoretically this field could hold flags for the resource, but appears to always be 0.</dd>

<dt><code class="ce">DWORD   TimeDateStamp</code></dt>

<dd>The time/date stamp describing the creation time of the resource.</dd>

<dt><code class="ce">WORD    MajorVersion</code></dt>

<dt><code class="ce">WORD    MinorVersion</code></dt>

<dd>Theoretically these fields would hold a version number for the resource. These field appear to always be set to 0.</dd>
</dl>

<p><code class="ce">WORD    NumberOfNamedEntries</code></p>

<p>The number of array elements that use names and that follow this structure.

</p><dl>
<dt><code class="ce">WORD    NumberOfIdEntries</code></dt>

<dd>The number of array elements that use integer IDs, and which follow this structure.</dd>

<dt><code class="ce">IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]</code></dt>

<dd>This field isn't really part of the IMAGE_RESOURCE_DIRECTORY structure. Rather, it's an array of IMAGE_RESOURCE_DIRECTORY_ENTRY structures that immediately follow the IMAGE_RESOURCE_DIRECTORY structure. The number of elements in the array is the sum of the NumberOfNamedEntries and NumberOfIdEntries fields. The directory entry elements that have name identifiers (rather than integer IDs) come first in the array.</dd>
</dl>

<p>A directory entry can either point at a subdirectory (that is, to another IMAGE_RESOURCE_DIRECTORY), or it can point to the raw data for a resource. Generally, there are at least three directory levels before you get to the actual raw resource data. The top-level directory (of which there's only one) is always found at the beginning of the resource section (.rsrc). The subdirectories of the top-level directory correspond to the various types of resources found in the file. For example, if a PE file includes dialogs, string tables, and menus, there will be three subdirectories: a dialog directory, a string table directory, and a menu directory. Each of these type subdirectories will in turn have ID subdirectories. There will be one ID subdirectory for each instance of a given resource type. In the above example, if there are three dialog boxes, the dialog directory will have three ID subdirectories. Each ID subdirectory will have either a string name (such as "MyDialog") or the integer ID used to identify the resource in the RC file. Figure 5 shows a resource directory hierarchy example in visual form. Table 13 shows the PEDUMP output for the resources in the Windows NT CLOCK.EXE.</p>

<p class="fig"><code><img id="peeringpe5" alt="ms809762.peeringpe5(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC105138.gif" title="ms809762.peeringpe5(en-us,MSDN.10).gif" xmlns="" /></code></p>

<p class="label"><strong>Figure 5. Resource directory hierarchy</strong></p>

<p class="label"><strong>Table 13. Resources Hierarchy for CLOCK.EXE </strong></p>


<div id="code-snippet-18" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_988ac61e-70d1-465e-8089-2f36bddb4c41');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_988ac61e-70d1-465e-8089-2f36bddb4c41" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
ResDir (0) Named:00 ID:06 TimeDate:2C3601DB Vers:0.00 Char:0
    ResDir (ICON) Named:00 ID:02 TimeDate:2C3601DB Vers:0.00 Char:0
        ResDir (1) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000200
        ResDir (2) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000210
    ResDir (MENU) Named:02 ID:00 TimeDate:2C3601DB Vers:0.00 Char:0
        ResDir (CLOCK) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000220
        ResDir (GENERICMENU) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000230
    ResDir (DIALOG) Named:01 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
        ResDir (ABOUTBOX) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000240
        ResDir (64) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000250
    ResDir (STRING) Named:00 ID:03 TimeDate:2C3601DB Vers:0.00 Char:0
        ResDir (1) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000260
        ResDir (2) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000270
        ResDir (3) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000280
    ResDir (GROUP_ICON) Named:01 ID:00 TimeDate:2C3601DB Vers:0.00 Char:0
        ResDir (CCKK) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 00000290
    ResDir (VERSION) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
        ResDir (1) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0
            ID: 00000409  Offset: 000002A0
  
</pre></div>
            
        </div>
    </div>
</div>


<p>As mentioned earlier, each directory entry is a structure of type IMAGE_RESOURCE_DIRECTORY_ENTRY (boy, these names are getting long!). Each IMAGE_RESOURCE_DIRECTORY_ENTRY has the format shown in Table 13.</p>

<p class="label"><strong>Table 14. IMAGE_RESOURCE_DIRECTORY_ENTRY Format</strong>

</p><dl>
<dt><code class="ce">DWORD   Name</code></dt>

<dd>This field contains either an integer ID or a pointer to a structure that contains a string name. If the high bit (0x80000000) is zero, this field is interpreted as an integer ID. If the high bit is nonzero, the lower 31 bits are an offset (relative to the start of the resources) to an IMAGE_RESOURCE_DIR_STRING_U structure. This structure contains a WORD character count, followed by a UNICODE string with the resource name. Yes, even PE files intended for non-UNICODE Win32 implementations use UNICODE here. To convert the UNICODE string to an ANSI string, use the WideCharToMultiByte function.</dd>

<dt><code class="ce">DWORD   OffsetToData</code></dt>

<dd>This field is either an offset to another resource directory or a pointer to information about a specific resource instance. If the high bit (0x80000000) is set, this directory entry refers to a subdirectory. The lower 31 bits are an offset (relative to the start of the resources) to another IMAGE_RESOURCE_DIRECTORY. If the high bit isn't set, the lower 31 bits point to an IMAGE_RESOURCE_DATA_ENTRY structure. The IMAGE_RESOURCE_DATA_ENTRY structure contains the location of the resource's raw data, its size, and its code page.</dd>
</dl>

<p>To go further into the resource formats, I'd need to discuss the format of each resource type (dialogs, menus, and so on). Covering these topics could easily fill up an entire article on its own. </p>

<h2 class="dtH1">PE File Base Relocations</h2>

<p>When the linker creates an EXE file, it makes an assumption about where the file will be mapped into memory. Based on this, the linker puts the real addresses of code and data items into the executable file. If for whatever reason the executable ends up being loaded somewhere else in the virtual address space, the addresses the linker plugged into the image are wrong. The information stored in the .reloc section allows the PE loader to fix these addresses in the loaded image so that they're correct again. On the other hand, if the loader was able to load the file at the base address assumed by the linker, the .reloc section data isn't needed and is ignored. The entries in the .reloc section are called base relocations since their use depends on the base address of the loaded image.</p>

<p>Unlike relocations in the NE file format, base relocations are extremely simple. They boil down to a list of locations in the image that need a value added to them. The format of the base relocation data is somewhat quirky. The base relocation entries are packaged in a series of variable length chunks. Each chunk describes the relocations for one 4KB page in the image. Let's look at an example to see how base relocations work. An executable file is linked assuming a base address of 0x10000. At offset 0x2134 within the image is a pointer containing the address of a string. The string starts at physical address 0x14002, so the pointer contains the value 0x14002. You then load the file, but the loader decides that it needs to map the image starting at physical address 0x60000. The difference between the linker-assumed base load address and the actual load address is called the delta. In this case, the delta is 0x50000. Since the entire image is 0x50000 bytes higher in memory, so is the string (now at address 0x64002). The pointer to the string is now incorrect. The executable file contains a base relocation for the memory location where the pointer to the string resides. To resolve a base relocation, the loader adds the delta value to the original value at the base relocation address. In this case, the loader would add 0x50000 to the original pointer value (0x14002), and store the result (0x64002) back into the pointer's memory. Since the string really is at 0x64002, everything is fine with the world. </p>

<p>Each chunk of base relocation data begins with an IMAGE_BASE_RELOCATION structure that looks like Table 14. Table 15 shows some base relocations as shown by PEDUMP. Note that the RVA values shown have already been displaced by the VirtualAddress in the IMAGE_BASE_RELOCATION field.</p>

<p class="label"><strong>Figure 15. IMAGE_BASE_RELOCATION Format</strong>

</p><dl>
<dt><code class="ce">DWORD   VirtualAddress</code></dt>

<dd>This field contains the starting RVA for this chunk of relocations. The offset of each relocation that follows is added to this value to form the actual RVA where the relocation needs to be applied.</dd>

<dt><code class="ce">DWORD   SizeOfBlock</code></dt>

<dd>The size of this structure plus all the WORD relocations that follow. To determine the number of relocations in this block, subtract the size of an IMAGE_BASE_RELOCATION (8 bytes) from the value of this field, and then divide by 2 (the size of a WORD). For example, if this field contains 44, there are 18 relocations that immediately follow: 


<div id="code-snippet-19" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_abd65a72-5662-4148-9b5b-33447463eb64');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_abd65a72-5662-4148-9b5b-33447463eb64" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
 (44 - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD) = 18
WORD TypeOffset
  
</pre></div>
            
        </div>
    </div>
</div>

</dd>
</dl>

<blockquote class="dtBlock"><div>
This isn't just a single WORD, but rather an array of WORDs, the number of which is calculated by the above formula. The bottom 12 bits of each WORD are a relocation offset, and need to be added to the value of the Virtual Address field from this relocation block's header. The high 4 bits of each WORD are a relocation type. For PE files that run on Intel CPUs, you'll only see two types of relocations:</div></blockquote>
<div class="tablediv"><table class="dtTABLE">

<tr><td>0</td><td>IMAGE_REL_BASED_ABSOLUTE</td><td>This relocation is meaningless and is only used as a place holder to round relocation blocks up to a DWORD multiple size.</td></tr>

<tr><td>3</td><td>IMAGE_REL_BASED_HIGHLOW</td><td>This relocation means add both the high and low 16 bits of the delta to the DWORD specified by the calculated RVA.</td></tr>
</table></div>

<p class="label"><strong>Table 16. The Base Relocations from an EXE File </strong></p>


<div id="code-snippet-20" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_faf1f5fa-5574-4ea9-b416-6855dd35bd21');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_faf1f5fa-5574-4ea9-b416-6855dd35bd21" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
Virtual Address: 00001000  size: 0000012C
  00001032 HIGHLOW
  0000106D HIGHLOW
  000010AF HIGHLOW
  000010C5 HIGHLOW
  // Rest of chunk omitted...
Virtual Address: 00002000  size: 0000009C
  000020A6 HIGHLOW
  00002110 HIGHLOW
  00002136 HIGHLOW
  00002156 HIGHLOW
  // Rest of chunk omitted...
Virtual Address: 00003000  size: 00000114
  0000300A HIGHLOW
  0000301E HIGHLOW
  0000303B HIGHLOW
  0000306A HIGHLOW
  // Rest of relocations omitted...

</pre></div>
            
        </div>
    </div>
</div>


<h2 class="dtH1">Differences Between PE and COFF OBJ Files</h2>

<p>There are two portions of the PE file that are not used by the operating system. These are the COFF symbol table and the COFF debug information. Why would anyone need COFF debug information when the much more complete CodeView information is available? If you intend to use the Windows NT system debugger (NTSD) or the Windows NT kernel debugger (KD), COFF is the only game in town. For those of you who are interested, I've included a detailed description of these parts of the PE file in the online posting that accompanies this article (available on all MSJ bulletin boards). </p>

<p>At many points throughout the preceding discussion, I've noted that many structures and tables are the same in both a COFF OBJ file and the PE file  created from it. Both COFF OBJ and PE files have an IMAGE_FILE_HEADER at or near their beginning. This header is followed by a section table that contains information about all the sections in the file. The two formats also share the same line number and symbol table formats, although the PE file can have additional non-COFF symbol tables as well. The amount of commonality between the OBJ and PE EXE formats is evidenced by the large amount of common code in PEDUMP (see COMMON.C on any MSJ bulletin board).</p>

<p>This similarity between the two file formats isn't happenstance. The goal of this design is to make the linker's job as easy as possible. Theoretically, creating an EXE file from a single OBJ should be just a matter of inserting a few tables and modifying a couple of file offsets within the image. With this in mind, you can think of a COFF file as an embryonic PE file. Only a few things are missing or different, so I'll list them here.

</p><ul>
	<li>COFF OBJ files don't have an MS-DOS stub preceding the IMAGE_FILE_HEADER, nor is there a "PE" signature preceding the IMAGE_FILE_HEADER.</li>

	<li>OBJ files don't have the IMAGE_OPTIONAL_HEADER. In a PE file, this structure immediately follows the IMAGE_FILE_HEADER. Interestingly, COFF LIB files do have an IMAGE_OPTIONAL_HEADER. Space constraints prevent me from talking about LIB files here.</li>

	<li>OBJ files don't have base relocations. Instead, they have regular symbol-based fixups. I haven't gone into the format of the COFF OBJ file relocations because they're fairly obscure. If you want to dig into this particular area, the PointerToRelocations and NumberOfRelocations fields in the section table entries point to the relocations for each section. The relocations are an array of IMAGE_RELOCATION structures, which is defined in WINNT.H. The PEDUMP program can show OBJ file relocations if you enable the proper switch. </li>

	<li>The CodeView information in an OBJ file is stored in two sections (.debug$S and .debug$T). When the linker processes the OBJ files, it doesn't put these sections in the PE file. Instead, it collects all these sections and builds a single symbol table stored at the end of the file. This symbol table isn't a formal section (that is, there's no entry for it in the PE's section table).</li>
</ul>

<h2 class="dtH1">Using PEDUMP</h2>

<p>PEDUMP is a command-line utility for dumping PE files and COFF OBJ format files. It uses the Win32 console capabilities to eliminate the need for extensive user interface work. The syntax for PEDUMP is as follows:</p>


<div id="code-snippet-21" class="codeSnippetContainer" xmlns="">
    <div class="codeSnippetContainerTabs">
        
    </div>
    <div class="codeSnippetContainerCodeContainer">
        <div class="codeSnippetToolBar">
            <div class="codeSnippetToolBarText">
                <a name="CodeSnippetCopyLink" style="display: none;" title="Copy to clipboard." href="javascript:if (window.epx.codeSnippet)window.epx.codeSnippet.copyCode('CodeSnippetContainerCode_5d69cbc8-d048-40f8-aaf7-d6582f561a4e');">Copy</a>
            </div>
        </div>
        <div id="CodeSnippetContainerCode_5d69cbc8-d048-40f8-aaf7-d6582f561a4e" class="codeSnippetContainerCode" dir="ltr">
            <div style="color:Black;"><pre>
PEDUMP [switches] filename
  
</pre></div>
            
        </div>
    </div>
</div>


<p>The switches can be seen by running PEDUMP with no arguments. PEDUMP uses the switches shown in Table 17. By default, none of the switches are enabled. Running PEDUMP without any of the switches provides most of the useful information without creating a huge amount of output. PEDUMP sends its output to the standard output file, so its output can be redirected to a file with an &gt; on the command line.</p>

<p class="label"><strong>Table 17. PEDUMP Switches</strong></p>
<div class="tablediv"><table class="dtTABLE">

<tr><td>/A</td><td>Include everything in dump (essentially, enable all the switches)</td></tr>

<tr><td>/H</td><td>Include a hex dump of each section at the end of the dump</td></tr>

<tr><td>/L</td><td>Include line number information (both PE and COFF OBJ files)</td></tr>

<tr><td>/R</td><td>Show base relocations (PE files only)</td></tr>

<tr><td>/S</td><td>Show symbol table (both PE and COFF OBJ files)</td></tr>
</table></div>

<h2 class="dtH1">Summary</h2>

<p>With the advent of Win32, Microsoft made sweeping changes in the OBJ and executable file formats to save time and build on work previously done for other operating systems. A primary goal of these file formats is to enhance portability across different platforms.</p>

 
</div> 

</div>


    




<div class="libraryMemberFilter">
    <div class="filterContainer">
        <span>Show:</span>
        <label>
            <input type="checkbox" class="libraryFilterInherited" checked="checked" value="Inherit" />Inherited
        </label>
        <label>
            <input type="checkbox" class="libraryFilterProtected" checked="checked" value="Protected" />Protected
        </label>
    </div>
</div>
    
<input type="hidden" id="libraryMemberFilterEmptyWarning" value="There are no members available with your current filter settings." />



    </div>

<div id="rightNavigationMenu" ms.pgarea="right nav">
    <div id="mobileButtons">
        <div id="navigationButtons">
            <a id="provideFeedback1" href="javascript:void(0)"><ins class="suggestion"></ins>Any suggestions?</a>
            <a id="isd_print" href="https://msdn.microsoft.com/en-us/library/ms809762(d=printer).aspx" rel="nofollow"><ins class="print"></ins>Print </a>
            <a id="isd_printABook" href="/en-us/library/export/help/?returnUrl=%2fen-us%2flibrary%2fms809762.aspx">
                <ins class="export"></ins>Export (<span class="count">0</span>)
            </a>
        </div>
    </div>
    <div id="navMain">
        <div id="closeNavigation">
            <a class="tocCloseSmall" id="closeButton"></a>
        </div>
        <div id="navigationButtons">
            <a id="provideFeedback2" href="javascript:void(0)"><ins class="suggestion"></ins>Any suggestions?</a>
            <a id="isd_print" href="https://msdn.microsoft.com/en-us/library/ms809762(d=printer).aspx" rel="nofollow"><ins class="print"></ins>Print </a>
            <a id="isd_printABook2" href="/en-us/library/export/help/?returnUrl=%2fen-us%2flibrary%2fms809762.aspx">
                <ins class="export"></ins>Export (<span class="count">0</span>)
            </a>
            <a id="isdShare" href="#">
                <ins class="share"></ins>Share
            </a>
            <div id="socials" style="display: none">
                <a id="isdFacebook" href="#">
                    <ins class="facebook"></ins>
                </a>
                <a id="isdTwitter" href="#">
                    <ins class="twitter"></ins>
                </a>
                <a id="isdGooglePlus" href="#">
                    <ins class="googlePlus"></ins>
                </a>
            </div>
        </div>
        <div id="indoc_toc" style="display: none" ms.cmpgrp="indoc toc">
            <div id="indoc_title">IN THIS ARTICLE</div>
            <ul id="indoc_toclist"></ul>
        </div>
    </div>
</div>
<div id="rightNavigationMenuThumbnail" class="rightNavigationMenuThumbnail">
</div>



        </div>
        <div class="clear"></div>

        

<input name="__RequestVerificationToken" type="hidden" value="-AQOG0hN8v0mZJdrAdI8eC6k5AzSLVSUDnbdQiGK_PKEc9qaFKA3i-aDy0f6HwAX79qyCFg4FmwlUOSyTm9g1q2QoV41" />
<input id="ratingValueSubmitUrl" type="hidden" value="https://msdn.microsoft.com/en-us/library/feedback/rate/ms809762.aspx" />
<input id="ratingAdditionalSubmitUrl" type="hidden" value="https://msdn.microsoft.com/en-us/library/feedback/additional/ms809762.aspx" />
<input id="isTopicRated" type="hidden" value="false" />



    <div id="lib-footer">
            <div id="responsiveRating" ms.pgarea="rating">
                    
    <div id="skinnyRating">
        <div class="closeSmallWhite"></div>
        <div class="rating">
            <div id="s_ratingSection1">
                <div class="title">
                    Was this page helpful?
                </div>
                <div class="buttons">
                    <button class="button" id="s_ratingYes" aria-label="Yes, this page was helpful">Yes</button>
                    <button class="button" id="s_ratingNo" aria-label="No, this page was not helpful">No</button>
                </div>
                <input id="s_ratingValue" type="hidden" value="" />
            </div>
            <div id="s_ratingSection2">
                <div id="s_skinnyRatingForm">
                    <div class="title">
                        Additional feedback?
                    </div>
                    <textarea id="s_ratingText" rows="6" cols="" maxlength="1500"></textarea>
                    <div class="right">
                        <div class="counter">
                            <span id="feedbackTextCounter">1500</span> characters remaining
                        </div>
                        <div class="buttons">
                            <button class="button" id="s_ratingSubmit" aria-label="Submit my additional feedback">Submit</button>
                            <button class="button" id="s_ratingSkipThis" aria-label="Skip additional feedback">Skip this</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="s_ratingSection3" style="display: none">
                <div class="title">
                    Thank you!
                </div>
                <div class="description">
                    We appreciate your feedback.
                </div>
            </div>
            
            <div id="contentFeedbackQAContainer" style="display: none;"></div>
        </div>
    </div>
        

            </div>
        

    
    <link type="text/css" rel="stylesheet" />
    
        
    <div id="ux-footer" class="" style="" dir="ltr">
        
            
        <div id="footerSock" class="both">
            <div id="footerSockInner">
                             
                    <div class="footerSockLeft"><div data-fragmentName="SocialLinks" id="Fragment_SocialLinks" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <div class="linkListTitle">Follow us</div>
    <ul class="links">
      <li>
        <a href="http://www.facebook.com/microsoftdeveloper" target="_blank" id="SocialLinks_2151_19" class="facebook" xmlns="http://www.w3.org/1999/xhtml">http://www.facebook.com/microsoftdeveloper</a>
      </li>
      <li>
        <a href="https://twitter.com/msdev" target="_blank" id="SocialLinks_2151_20" class="twitter" xmlns="http://www.w3.org/1999/xhtml">https://twitter.com/msdev</a>
      </li>
      <li>
        <a href="http://plus.google.com/111221966647232053570/" target="_blank" id="SocialLinks_2151_21" class="googlePlus" xmlns="http://www.w3.org/1999/xhtml">http://plus.google.com/111221966647232053570/</a>
      </li>
    </ul>
  </div>
</div></div>
                        
                <div class="footerSockCenter">
                        <a name="feedback"></a>

<div class="rating">
    <div id="ratingSection1">
        <div class="title">
            Was this page helpful?
        </div>
        <div class="description">
            Your feedback about this content is important.<br />Let us know what you think.
        </div>
        <div class="buttons">
            <button class="button" id="ratingYes" aria-label="Yes, this page was helpful">Yes</button>
            <button class="button" id="ratingNo" aria-label="No, this page was not helpful">No</button>
        </div>
        <input id="ratingValue" type="hidden" value="" />
    </div>
    <div id="ratingSection2">
        <div class="title left">
            Additional feedback?
        </div>
        <textarea id="ratingText" rows="6" cols="" maxlength="1500"></textarea>
        <div class="right">
            <div class="counter">
                <span id="feedbackTextCounter">1500</span> characters remaining
            </div>
            <div class="buttons">
                <button class="button" id="ratingSubmit" aria-label="Submit my additional feedback">Submit</button>
                <button class="button" id="ratingSkipThis" aria-label="Skip additional feedback">Skip this</button>
            </div>
        </div>
    </div>
    <div id="ratingSection3">
        <div class="title">
            Thank you!
        </div>
        <div class="description">
            We appreciate your feedback.
        </div>
    </div>
    
    
    <div id="contentFeedbackQAContainer" style="display: none;"></div>
</div>
    
                    <div class="userVoice">
    <div class="title">
        Help us improve MSDN.
    </div>
        <div class="description">
            Visit our UserVoice Page to submit and vote on ideas!
        </div>
    <div class="buttons">
        <a class="button" id="userVoiceButton" href="http://feedback.msdn.com/forums/257782-msdn-feature-suggestions/category/83975" target="_blank">Make a suggestion</a>
    </div>
</div>  
                </div>
                <div class="clear"></div>
            </div>
        </div>

        <footer class="top">
            <div data-fragmentName="LeftLinks" id="Fragment_LeftLinks" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <div class="linkListTitle">Dev centers</div>
    <ul class="links">
      <li>
        <a href="https://dev.windows.com" id="LeftLinks_2148_1" class="windowsBlue" xmlns="http://www.w3.org/1999/xhtml">Windows</a>
      </li>
      <li>
        <a href="http://dev.office.com" id="LeftLinks_2148_3" class="office" xmlns="http://www.w3.org/1999/xhtml">Office</a>
      </li>
      <li>
        <a href="https://msdn.microsoft.com/vstudio" id="LeftLinks_2148_4" class="visualStudio" xmlns="http://www.w3.org/1999/xhtml">Visual Studio</a>
      </li>
      <li>
        <a href="http://azure.microsoft.com/en-us/documentation/" target="_blank" id="LeftLinks_2148_12" xmlns="http://www.w3.org/1999/xhtml">Microsoft Azure</a>
      </li>
      <li>
        <a href="https://msdn.microsoft.com/developer-centers-msdn" id="LeftLinks_2148_5" xmlns="http://www.w3.org/1999/xhtml">More...</a>
      </li>
    </ul>
  </div>
</div>
            <div id="rightLinks">
                <div data-fragmentName="CenterLinks1" id="Fragment_CenterLinks1" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <div class="linkListTitle">Learning resources</div>
    <ul class="links">
      <li>
        <a href="http://www.microsoftvirtualacademy.com/" id="CenterLinks1_2151_4" xmlns="http://www.w3.org/1999/xhtml">Microsoft Virtual Academy</a>
      </li>
      <li>
        <a href="http://channel9.msdn.com/" id="CenterLinks1_2151_5" xmlns="http://www.w3.org/1999/xhtml">Channel 9</a>
      </li>
      <li>
        <a href="http://www.interoperabilitybridges.com/" id="CenterLinks1_2151_6" xmlns="http://www.w3.org/1999/xhtml">Interoperability Bridges</a>
      </li>
      <li>
        <a href="https://msdn.microsoft.com/magazine/" id="CenterLinks1_2151_7" xmlns="http://www.w3.org/1999/xhtml">MSDN Magazine</a>
      </li>
    </ul>
  </div>
</div>
                <div data-fragmentName="CenterLinks2" id="Fragment_CenterLinks2" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <div class="linkListTitle">Community</div>
    <ul class="links">
      <li>
        <a href="https://social.msdn.microsoft.com/forums/en-us/home" id="CenterLinks2_2151_8" xmlns="http://www.w3.org/1999/xhtml">Forums</a>
      </li>
      <li>
        <a href="http://blogs.msdn.com/b/developer-tools/" id="CenterLinks2_2151_9" xmlns="http://www.w3.org/1999/xhtml">Blogs</a>
      </li>
      <li>
        <a href="http://www.codeplex.com" id="CenterLinks2_2151_10" xmlns="http://www.w3.org/1999/xhtml">Codeplex</a>
      </li>
    </ul>
  </div>
</div>
                <div data-fragmentName="CenterLinks3" id="Fragment_CenterLinks3" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <div class="linkListTitle">Support</div>
    <ul class="links">
      <li>
        <a href="https://msdn.microsoft.com/hh361695" id="CenterLinks3_2151_11" xmlns="http://www.w3.org/1999/xhtml">Self support</a>
      </li>
    </ul>
  </div>
</div>
                <div data-fragmentName="CenterLinks4" id="Fragment_CenterLinks4" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <div class="linkListTitle">Programs</div>
    <ul class="links">
      <li>
        <a href="https://www.microsoft.com/bizspark/" id="CenterLinks4_2151_13" xmlns="http://www.w3.org/1999/xhtml">BizSpark (for startups)</a>
      </li>
      <li>
        <a href="https://www.dreamspark.com/" id="CenterLinks4_2151_14" xmlns="http://www.w3.org/1999/xhtml">DreamSpark</a>
      </li>
      <li>
        <a href="http://www.imaginecup.com" id="CenterLinks4_2151_17" xmlns="http://www.w3.org/1999/xhtml">Imagine Cup</a>
      </li>
    </ul>
  </div>
</div>
            </div>
        </footer>

        <footer class="bottom">
            <span class="localeContainer">
                
    <form class="selectLocale" id="selectLocaleForm" action="https://msdn.microsoft.com/en-us/selectlocale-dmc">
        <input type="hidden" name="fromPage" value="https%3a%2f%2fmsdn.microsoft.com%2fen-us%2flibrary%2fms809762.aspx" />
        <a href="#" onclick="$('#selectLocaleForm').submit();return false;" title="Change your language">United States (English)</a>
    </form>


            </span>

            <div data-fragmentName="BottomLinks" id="Fragment_BottomLinks" xmlns="http://www.w3.org/1999/xhtml">
  
  <div class="linkList">
    <ul class="links horizontal">
      <li>
        <a href="https://msdn.microsoft.com/newsletter.aspx" id="BottomLinks_2148_7" xmlns="http://www.w3.org/1999/xhtml">Newsletter</a>
      </li>
      <li>
        <a href="https://msdn.microsoft.com/dn529288" id="BottomLinks_2148_8" xmlns="http://www.w3.org/1999/xhtml">Privacy &amp; cookies</a>
      </li>
      <li>
        <a href="https://msdn.microsoft.com/cc300389" id="BottomLinks_2148_9" xmlns="http://www.w3.org/1999/xhtml">Terms of use</a>
      </li>
      <li>
        <a href="https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx" id="BottomLinks_2148_10" xmlns="http://www.w3.org/1999/xhtml">Trademarks</a>
      </li>
    </ul>
  </div>
</div>
            <span class="logoLegal">
                <span class="logo"></span>
                <span class="copyright">© 2015 Microsoft</span>
            </span>
        </footer>
    </div>
    

    </div>

        <div class="footerPrintView">
            <div class="footerCopyrightPrintView">© 2015 Microsoft</div>
        </div>

        
        

        
        
        

    <input id="tocPaddingPerLevel" type="hidden" value="17" />



        <input id="MtpsDevice" type="hidden" value="Default" />


<![CDATA[ Third party scripts and code linked to or referenced from this website are licensed to you by the parties that own such code, not by Microsoft.  See ASP.NET Ajax CDN Terms of Use – http://www.asp.net/ajaxlibrary/CDN.ashx. ]]>

        
        
        
            
        






<noscript><div><img alt="DCSIMG" id="Img1" width="1" height="1" src="https://m.webtrends.com/dcsmgru7m99k7mqmgrhudo0k8_8c6m/njs.gif?dcsuri=/nojavascript&amp;WT.js=No" /></div></noscript>








<div id="globalRequestVerification">
    <input name="__RequestVerificationToken" type="hidden" value="HmOcsVUwaIDKlM38lNaYCu2F31fHa_7pUZCqwGVzLhk7thX10sTa9RgSbeR6v8F1x2-IVwxLclg2-nccZSesEivIJc41" />
</div>


    </div>

    
    

    

    
    
    
<script type="text/javascript" class="mtps-injected">
/*<![CDATA[*/
(function(window,document){"use strict";function preload(scripts){for(var result=[],script,e,i=0;i<scripts.length;i++)script=scripts[i],script.hasOwnProperty("url")&&(e=document.createElement("script"),e.src=script.url,script.throwaway=e),result.push(script);return result}function inject(scripts,index){var script,elem;if(index>=scripts.length){delete mtps.injectScripts;return}script=scripts[index];elem=document.createElement("script");elem.className="mtps-injected";elem.async=!1;var isLoaded=!1,timeoutId=0,injectNextFnName="",injectNext=elem.onerror=function(){isLoaded||(isLoaded=!0,inject(scripts,index+1),window.clearTimeout(timeoutId),elem.onload=elem.onerror=elem.onreadystatechange=null,injectNextFnName&&delete mtps[injectNextFnName],elem.removeEventListener&&elem.removeEventListener("load",injectNext,!1))};elem.addEventListener?elem.addEventListener("load",injectNext,!1):elem.readyState==="uninitialized"?elem.onreadystatechange=function(){(this.readyState==="loaded"||this.readyState==="complete")&&injectNext()}:elem.onload=injectNext;script.hasOwnProperty("url")?(timeoutId=window.setTimeout(injectNext,12e4),elem.src=script.url):(injectNextFnName="_injectNextScript_"+index,mtps[injectNextFnName]=injectNext,timeoutId=window.setTimeout(injectNext,2e3),elem.text="try {\n"+script.txt+"\n} finally { MTPS."+injectNextFnName+" && MTPS."+injectNextFnName+"(); }");parent.appendChild(elem)}var mtps=window.MTPS||(window.MTPS={}),parent=document.getElementsByTagName("head")[0];mtps.injectScripts=function(scripts){inject(preload(scripts),0)}})(window,document);
MTPS.injectScripts([
	{ txt: "/**/\r\n(window.MTPS || (window.MTPS = {})).cdnDomains || (window.MTPS.cdnDomains = { \r\n\t\"image\": \"https://i-msdn.sec.s-msft.com\", \r\n\t\"js\": \"https://i2-msdn.sec.s-msft.com\", \r\n\t\"css\": \"https://i-msdn.sec.s-msft.com\", \r\n\t\"xap\": \"https://msdn.microsoft.com\"\r\n});\r\n/**/" },
	{ txt: "//\n  var literalNormalizedUrl = \u0027/en-us/library/ms809762(l=en-us,v=msdn.10).aspx\u0027;\n  var wt_nvr_ru = \u0027WT_NVR_RU\u0027;\n  var wt_fpcdom = \u0027.microsoft.com\u0027;\n  var wt_domlist = \u0027msdn.microsoft.com\u0027;\n  var wt_pathlist = \u0027\u0027;\n  var wt_paramlist = \u0027DCSext.mtps_devcenter\u0027;\n  var wt_siteid = \u0027MSDN\u0027;\n  var gDomain = \u0027m.webtrends.com\u0027;\n  var gDcsId = \u0027dcsmgru7m99k7mqmgrhudo0k8_8c6m\u0027;\n  var gFpc = \u0027WT_FPC\u0027;\n\n\n\n  if (document.cookie.indexOf(gFpc + \"=\") == -1) {\n    var wtidJs = document.createElement(\"script\");\n    wtidJs.src = \"//\" + gDomain + \"/\" + gDcsId + \"/wtid.js\";\n    document.getElementsByTagName(\"head\")[0].appendChild(wtidJs);\n  }\n\n\n\n  var detectedLocale = \u0027en-us\u0027;\n  var wtsp = \u0027msdnlib_w32_com\u0027;\n  var gTrackEvents = \u00270\u0027;\n/**/" },
	{ txt: "//\n\n        window.appInsightsId = \u002760854590-027a-4ae4-98be-2741a40f355f\u0027;\n        //" },
	{ url: "https://i2-msdn.sec.s-msft.com/Combined.js?resources=0:Utilities,1:Layout,2:Header,3:Breadcrumbs,4:LibraryRightNavigationMenu,4:PrintExportButton,5:SkinnyRating,1:Rating,2:Footer,0:Topic,6:webtrendsscript,0:AppInsightsPerf,3:ResponsiveToc,0:ABTestControl,4:WEDCS,3:CmpgrpForHeader,0:livefyre,0:Comment,1:SearchBox;/Areas/Epx/Content/Scripts:0,/Areas/Epx/Themes/Base/Content:1,/Areas/Centers/Themes/StandardDevCenter/Content:2,/Areas/Library/Content:3,/Areas/Library/Themes/Base/Content:4,/Areas/Library/Themes/Msdn/Content:5,/Areas/Global/Content/Webtrends/resources:6\u0026amp;hashKey=A0993E7E398069FAC3E026B62E3F9142\u0026amp;v=5A9AB0A0A76DFF0C4EBFD7EC98EF5BBB" },
	{ url: "https://i1.services.social.microsoft.com/search/Widgets/SearchBox.jss?boxid=HeaderSearchTextBox\u0026btnid=HeaderSearchButton\u0026pgArea=header\u0026brand=Msdn\u0026loc=en-us\u0026focusOnInit=false\u0026emptyWatermark=true\u0026searchButtonTooltip=Search MSDN" },
	{ url: "https://i2-msdn.sec.s-msft.com/Combined.js?resources=0:LibraryMemberFilter,1:Toc_Fixed,1:CodeSnippet,1:TopicNotInScope,0:ResponsiveSupport,1:VersionSelector,1:SurveyBroker;/Areas/Library/Content:0,/Areas/Epx/Content/Scripts:1\u0026amp;hashKey=CDA41F7EA7DE185FBCE7B189AEA99930\u0026amp;v=5A9AB0A0A76DFF0C4EBFD7EC98EF5BBB" },
	{ txt: "$(document).ready(function() {\n        try {\n            var token = $(\"#globalRequestVerification input[name=\u0027__RequestVerificationToken\u0027]\").clone();\n            $(\"#siteFeedbackForm\").append(token);\n        } catch(err) {\n            \n        }\n    });" }
]);

/*]]>*/
</script></body>
</html>
